diff -ru sqlite-src-3260000/Makefile.in SQLumDash3.26.0/Makefile.in
--- sqlite-src-3260000/Makefile.in	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/Makefile.in	2019-01-16 11:03:53.000000000 +0900
@@ -70,6 +70,9 @@
 #
 TLIBS = @LIBS@ $(LIBS)
 
+# Add libm for new functions of SQLumDash
+TLIBS += -lm
+
 # Flags controlling use of the in memory btree implementation
 #
 # SQLITE_TEMP_STORE is 0 to force temporary tables to be in a file, 1 to
@@ -178,7 +181,7 @@
          fts3_tokenize_vtab.lo \
          fts3_unicode.lo fts3_unicode2.lo fts3_write.lo \
 	 fts5.lo \
-         func.lo global.lo hash.lo \
+         func.lo funcNew.lo global.lo hash.lo \
          icu.lo insert.lo json1.lo legacy.lo loadext.lo \
          main.lo malloc.lo mem0.lo mem1.lo mem2.lo mem3.lo mem5.lo \
          memdb.lo memjournal.lo \
@@ -191,7 +194,9 @@
          update.lo userauth.lo upsert.lo util.lo vacuum.lo \
          vdbe.lo vdbeapi.lo vdbeaux.lo vdbeblob.lo vdbemem.lo vdbesort.lo \
          vdbetrace.lo wal.lo walker.lo where.lo wherecode.lo whereexpr.lo \
-         window.lo utf.lo vtab.lo
+         window.lo utf.lo vtab.lo \
+         rowlock.lo rowlock_hash.lo rowlock_ipc.lo rowlock_ipc_row.lo \
+         rowlock_ipc_table.lo rowlock_os_linux.lo rowlock_savepoint.lo
 
 # Object files for the amalgamation.
 #
@@ -227,6 +232,7 @@
   $(TOP)/src/fault.c \
   $(TOP)/src/fkey.c \
   $(TOP)/src/func.c \
+  $(TOP)/src/funcNew.c \
   $(TOP)/src/global.c \
   $(TOP)/src/hash.c \
   $(TOP)/src/hash.h \
@@ -308,6 +314,31 @@
   $(TOP)/src/whereInt.h \
   $(TOP)/src/window.c
 
+# Source code for SQLumDash
+#
+SRC += \
+  $(TOP)/src/rowlock.c \
+  $(TOP)/src/rowlock.h \
+  $(TOP)/src/rowlock_btree.c \
+  $(TOP)/src/rowlock_hash.c \
+  $(TOP)/src/rowlock_hash.h \
+  $(TOP)/src/rowlock_ipc.c \
+  $(TOP)/src/rowlock_ipc.h \
+  $(TOP)/src/rowlock_ipc_row.c \
+  $(TOP)/src/rowlock_ipc_row.h \
+  $(TOP)/src/rowlock_ipc_table.c \
+  $(TOP)/src/rowlock_ipc_table.h \
+  $(TOP)/src/rowlock_macro.h \
+  $(TOP)/src/rowlock_main.c \
+  $(TOP)/src/rowlock_os.h \
+  $(TOP)/src/rowlock_os_linux.c \
+  $(TOP)/src/rowlock_os_linux.h \
+  $(TOP)/src/rowlock_os_win.c \
+  $(TOP)/src/rowlock_os_win.h \
+  $(TOP)/src/rowlock_pager.c \
+  $(TOP)/src/rowlock_savepoint.c \
+  $(TOP)/src/rowlock_savepoint.h
+  
 # Source code for extensions
 #
 SRC += \
@@ -476,6 +507,7 @@
   $(TOP)/src/dbstat.c \
   $(TOP)/src/expr.c \
   $(TOP)/src/func.c \
+  $(TOP)/src/funcNew.c \
   $(TOP)/src/global.c \
   $(TOP)/src/insert.c \
   $(TOP)/src/wal.c \
@@ -504,6 +536,14 @@
   $(TOP)/src/wherecode.c \
   $(TOP)/src/whereexpr.c \
   $(TOP)/src/window.c \
+  $(TOP)/src/rowlock.c \
+  $(TOP)/src/rowlock_hash.c \
+  $(TOP)/src/rowlock_ipc.c \
+  $(TOP)/src/rowlock_ipc_row.c \
+  $(TOP)/src/rowlock_ipc_table.c \
+  $(TOP)/src/rowlock_os_linux.c \
+  $(TOP)/src/rowlock_os_win.c \
+  $(TOP)/src/rowlock_savepoint.c \
   parse.c \
   $(TOP)/ext/fts3/fts3.c \
   $(TOP)/ext/fts3/fts3_aux.c \
@@ -520,6 +560,7 @@
 HDR = \
    $(TOP)/src/btree.h \
    $(TOP)/src/btreeInt.h \
+   $(TOP)/src/funcNew.h \
    $(TOP)/src/hash.h \
    $(TOP)/src/hwtime.h \
    keywordhash.h \
@@ -542,6 +583,16 @@
    $(TOP)/src/vdbeInt.h \
    $(TOP)/src/vxworks.h \
    $(TOP)/src/whereInt.h \
+   $(TOP)/src/rowlock.h \
+   $(TOP)/src/rowlock_hash.h \
+   $(TOP)/src/rowlock_ipc.h \
+   $(TOP)/src/rowlock_ipc_row.h \
+   $(TOP)/src/rowlock_ipc_table.h \
+   $(TOP)/src/rowlock_macro.h \
+   $(TOP)/src/rowlock_os.h \
+   $(TOP)/src/rowlock_os_linux.h \
+   $(TOP)/src/rowlock_os_win.h \
+   $(TOP)/src/rowlock_savepoint.h \
    config.h
 
 # Header files used by extensions
@@ -617,7 +668,7 @@
 # This is the default Makefile target.  The objects listed here
 # are what get build when you type just "make" with no arguments.
 #
-all:	sqlite3.h libsqlite3.la sqlite3$(TEXE) $(HAVE_TCL:1=libtclsqlite3.la)
+all:	sqlite3.h libsqlite3.la sqlite3$(TEXE) $(HAVE_TCL:1=libtclsqlite3.la) sqlumdash_cleaner
 
 Makefile: $(TOP)/Makefile.in
 	./config.status
@@ -831,6 +882,9 @@
 func.lo:	$(TOP)/src/func.c $(HDR)
 	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/func.c
 
+funcNew.lo:	$(TOP)/src/funcNew.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/funcNew.c
+
 global.lo:	$(TOP)/src/global.c $(HDR)
 	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/global.c
 
@@ -1002,6 +1056,27 @@
 window.lo:	$(TOP)/src/window.c $(HDR)
 	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/window.c
 
+rowlock.lo:	$(TOP)/src/rowlock.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock.c
+
+rowlock_hash.lo:	$(TOP)/src/rowlock_hash.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_hash.c
+
+rowlock_ipc.lo:	$(TOP)/src/rowlock_ipc.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_ipc.c
+
+rowlock_ipc_row.lo:	$(TOP)/src/rowlock_ipc_row.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_ipc_row.c
+
+rowlock_ipc_table.lo:	$(TOP)/src/rowlock_ipc_table.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_ipc_table.c
+
+rowlock_os_linux.lo:	$(TOP)/src/rowlock_os_linux.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_os_linux.c
+
+rowlock_savepoint.lo:	$(TOP)/src/rowlock_savepoint.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_savepoint.c
+
 tclsqlite.lo:	$(TOP)/src/tclsqlite.c $(HDR)
 	$(LTCOMPILE) -DUSE_TCL_STUBS=1 -c $(TOP)/src/tclsqlite.c
 
@@ -1060,6 +1135,14 @@
 
 
 
+# Rules to build the cleanup tool of lowlock
+#
+CLEANER_SRC = \
+	$(TOP)/tool/rowlock_cleaner.c
+
+sqlumdash_cleaner:	 $(CLEANER_SRC) $(SQLITE3H)
+	$(TCC) -o sqlumdash_cleaner -I$(TOP) -L.libs -lsqlite3 $(OPT_FEATURE_FLAGS) $(OPTS) $(CLEANER_SRC)
+
 # Rules to build the extension objects.
 #
 icu.lo:	$(TOP)/ext/icu/icu.c $(HDR) $(EXTHDR)
@@ -1427,6 +1510,8 @@
 	rm -f sqldiff sqldiff.exe
 	rm -f dbhash dbhash.exe
 	rm -f fts5.* fts5parse.*
+	rm -f sqlumdash_cleaner sqlumdash_cleaner
+
 
 distclean:	clean
 	rm -f config.h config.log config.status libtool Makefile sqlite3.pc
diff -ru sqlite-src-3260000/Makefile.msc SQLumDash3.26.0/Makefile.msc
--- sqlite-src-3260000/Makefile.msc	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/Makefile.msc	2019-01-16 11:03:53.000000000 +0900
@@ -951,8 +951,8 @@
 
 # Should the database engine be compiled threadsafe
 #
-TCC = $(TCC) -DSQLITE_THREADSAFE=1
-RCC = $(RCC) -DSQLITE_THREADSAFE=1
+TCC = $(TCC) -DSQLITE_THREADSAFE=2
+RCC = $(RCC) -DSQLITE_THREADSAFE=2
 
 # Do threads override each others locks by default (1), or do we test (-1)
 #
@@ -965,6 +965,8 @@
 TLIBS =
 !ENDIF
 
+TLIBS = $(TLIBS) advapi32.lib
+
 # Flags controlling use of the in memory btree implementation
 #
 # SQLITE_TEMP_STORE is 0 to force temporary tables to be in a file, 1 to
@@ -1156,6 +1158,9 @@
 !ENDIF
 !ENDIF
 
+# Add linking library for MMAP.
+LTLINKOPTS = $(LTLINKOPTS) advapi32.lib
+
 # If either debugging or symbols are enabled, enable PDBs.
 #
 !IF $(DEBUG)>1 || $(SYMBOLS)!=0
@@ -1202,7 +1207,7 @@
          fts3_porter.lo fts3_snippet.lo fts3_tokenizer.lo fts3_tokenizer1.lo \
          fts3_tokenize_vtab.lo fts3_unicode.lo fts3_unicode2.lo fts3_write.lo \
          fts5.lo \
-         func.lo global.lo hash.lo \
+         func.lo funcNew.lo global.lo hash.lo \
          icu.lo insert.lo json1.lo legacy.lo loadext.lo \
          main.lo malloc.lo mem0.lo mem1.lo mem2.lo mem3.lo mem5.lo \
          memdb.lo memjournal.lo \
@@ -1215,7 +1220,9 @@
          update.lo upsert.lo util.lo vacuum.lo \
          vdbeapi.lo vdbeaux.lo vdbeblob.lo vdbemem.lo vdbesort.lo \
          vdbetrace.lo wal.lo walker.lo where.lo wherecode.lo whereexpr.lo \
-         window.lo utf.lo vtab.lo
+         window.lo utf.lo vtab.lo \
+         rowlock.lo rowlock_hash.lo rowlock_ipc.lo rowlock_ipc_row.lo \
+         rowlock_ipc_table.lo rowlock_os_win.lo rowlock_savepoint.lo
 # <</mark>>
 
 # Object files for the amalgamation.
@@ -1266,6 +1273,7 @@
   $(TOP)\src\fault.c \
   $(TOP)\src\fkey.c \
   $(TOP)\src\func.c \
+  $(TOP)\src\funcNew.c \
   $(TOP)\src\global.c \
   $(TOP)\src\hash.c \
   $(TOP)\src\insert.c \
@@ -1327,7 +1335,18 @@
   $(TOP)\src\where.c \
   $(TOP)\src\wherecode.c \
   $(TOP)\src\whereexpr.c \
-  $(TOP)\src\window.c
+  $(TOP)\src\window.c \
+  $(TOP)\src\rowlock.c \
+  $(TOP)\src\rowlock_btree.c \
+  $(TOP)\src\rowlock_hash.c \
+  $(TOP)\src\rowlock_ipc.c \
+  $(TOP)\src\rowlock_ipc_row.c \
+  $(TOP)\src\rowlock_ipc_table.c \
+  $(TOP)\src\rowlock_main.c \
+  $(TOP)\src\rowlock_os_linux.c \
+  $(TOP)\src\rowlock_os_win.c \
+  $(TOP)\src\rowlock_pager.c \
+  $(TOP)\src\rowlock_savepoint.c
 
 # Core miscellaneous files.
 #
@@ -1339,6 +1358,7 @@
 SRC04 = \
   $(TOP)\src\btree.h \
   $(TOP)\src\btreeInt.h \
+  $(TOP)\src\funcNew.h \
   $(TOP)\src\hash.h \
   $(TOP)\src\hwtime.h \
   $(TOP)\src\msvc.h \
@@ -1362,7 +1382,17 @@
   $(TOP)\src\vdbeInt.h \
   $(TOP)\src\vxworks.h \
   $(TOP)\src\wal.h \
-  $(TOP)\src\whereInt.h
+  $(TOP)\src\whereInt.h \
+  $(TOP)\src\rowlock.h \
+  $(TOP)\src\rowlock_hash.h \
+  $(TOP)\src\rowlock_ipc.h \
+  $(TOP)\src\rowlock_ipc_row.h \
+  $(TOP)\src\rowlock_ipc_table.h \
+  $(TOP)\src\rowlock_macro.h \
+  $(TOP)\src\rowlock_os.h \
+  $(TOP)\src\rowlock_os_linux.h \
+  $(TOP)\src\rowlock_os_win.h \
+  $(TOP)\src\rowlock_savepoint.h
 
 # Extension source code files, part 1.
 #
@@ -1460,11 +1490,13 @@
   $(TOP)\src\test2.c \
   $(TOP)\src\test3.c \
   $(TOP)\src\test4.c \
+  $(TOP)\src\test4_new.c \
   $(TOP)\src\test5.c \
   $(TOP)\src\test6.c \
   $(TOP)\src\test7.c \
   $(TOP)\src\test8.c \
   $(TOP)\src\test9.c \
+  $(TOP)\src\test_rowlock.c \
   $(TOP)\src\test_autoext.c \
   $(TOP)\src\test_async.c \
   $(TOP)\src\test_backup.c \
@@ -1578,7 +1610,16 @@
    $(TOP)\src\vdbe.h \
    $(TOP)\src\vdbeInt.h \
    $(TOP)\src\vxworks.h \
-   $(TOP)\src\whereInt.h
+   $(TOP)\src\whereInt.h \
+   $(TOP)\src\rowlock.h \
+   $(TOP)\src\rowlock_hash.h \
+   $(TOP)\src\rowlock_ipc.h \
+   $(TOP)\src\rowlock_ipc_row.h \
+   $(TOP)\src\rowlock_ipc_table.h \
+   $(TOP)\src\rowlock_macro.h \
+   $(TOP)\src\rowlock_os.h \
+   $(TOP)\src\rowlock_os_win.h \
+   $(TOP)\src\rowlock_savepoint.h
 
 # Header files used by extensions
 #
@@ -1666,7 +1707,7 @@
 # This is the default Makefile target.  The objects listed here
 # are what get build when you type just "make" with no arguments.
 #
-core:	dll libsqlite3.lib shell
+core:	dll libsqlite3.lib shell sqlumdash_cleaner.exe
 
 # Targets that require the Tcl library.
 #
@@ -1699,8 +1740,10 @@
 sqlite3.def:	libsqlite3.lib
 	echo EXPORTS > sqlite3.def
 	dumpbin /all libsqlite3.lib \
-		| $(TCLSH_CMD) $(TOP)\tool\replace.tcl include "^\s+1 _?(sqlite3(?:session|changeset|changegroup|rebaser)?_[^@]*)(?:@\d+)?$$" \1 \
-		| sort >> sqlite3.def
+		| $(TCLSH_CMD) $(TOP)\tool\replace.tcl include "^\s+[0-9A-F]+ _?(sqlite3(?:session|changeset|changegroup|rebaser)?_[^@]*)(?:@\d+)?$$" \1 \
+		| sort >> sqlite3.def.tmp
+	.\tool\win\uniq.bat sqlite3.def.tmp >> sqlite3.def
+	del sqlite3.def.tmp
 # <</block2>>
 
 $(SQLITE3EXE):	shell.c $(SHELL_CORE_DEP) $(LIBRESOBJS) $(SHELL_CORE_SRC) $(SQLITE3H)
@@ -1903,6 +1946,9 @@
 func.lo:	$(TOP)\src\func.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\func.c
 
+funcNew.lo:	$(TOP)\src\funcNew.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\funcNew.c
+
 global.lo:	$(TOP)\src\global.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\global.c
 
@@ -2074,6 +2120,27 @@
 window.lo:	$(TOP)\src\window.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\window.c
 
+rowlock.lo:	$(TOP)\src\rowlock.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock.c
+
+rowlock_hash.lo:	$(TOP)\src\rowlock_hash.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_hash.c
+
+rowlock_ipc.lo:	$(TOP)\src\rowlock_ipc.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc.c
+
+rowlock_ipc_row.lo:	$(TOP)\src\rowlock_ipc_row.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc_row.c
+
+rowlock_ipc_table.lo:	$(TOP)\src\rowlock_ipc_table.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc_table.c
+
+rowlock_os_win.lo:	$(TOP)\src\rowlock_os_win.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_os_win.c
+
+rowlock_savepoint.lo:	$(TOP)\src\rowlock_savepoint.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_savepoint.c
+
 tclsqlite.lo:	$(TOP)\src\tclsqlite.c $(HDR) $(SQLITE_TCL_DEP)
 	$(LTCOMPILE) $(NO_WARN) -DUSE_TCL_STUBS=1 -DBUILD_sqlite -I$(TCLINCDIR) -c $(TOP)\src\tclsqlite.c
 
@@ -2145,6 +2212,15 @@
 zlib:
 	pushd $(ZLIBDIR) && $(MAKE) /f win32\Makefile.msc clean $(ZLIBLIB) && popd
 
+# Rules to build the rowlock cleaner
+#
+CLEANER_SRC = \
+	$(TOP)\tool\rowlock_cleaner.c
+
+sqlumdash_cleaner.exe:	 $(CLEANER_SRC) $(SQLITE3H)
+	$(TCC) $(NO_WARN) -Fe$@ $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) \
+		$(CLEANER_SRC) /link $(LDFLAGS) $(NLTLINKOPTS) $(NLTLIBPATHS) $(SQLITE3LIB) $(TLIBS)
+
 # Rules to build the extension objects.
 #
 icu.lo:	$(TOP)\ext\icu\icu.c $(HDR) $(EXTHDR)
@@ -2525,4 +2601,5 @@
 	del /Q showshm.exe sqlite3_checker.* sqlite3_expert.exe 2>NUL
 	del /Q fts5.* fts5parse.* 2>NUL
 	del /Q lsm.h lsm1.c 2>NUL
+	del /Q sqlumdash_cleaner.exe 2>NUL
 # <</mark>>
sqlite-src-3260000 のみに存在: compat
diff -ru sqlite-src-3260000/configure.ac SQLumDash3.26.0/configure.ac
--- sqlite-src-3260000/configure.ac	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/configure.ac	2018-12-14 10:34:09.000000000 +0900
@@ -188,12 +188,12 @@
   SQLITE_THREADSAFE=0
   AC_MSG_RESULT([no])
 else
-  SQLITE_THREADSAFE=1
+  SQLITE_THREADSAFE=2
   AC_MSG_RESULT([yes])
 fi
 AC_SUBST(SQLITE_THREADSAFE)
 
-if test "$SQLITE_THREADSAFE" = "1"; then
+if test "$SQLITE_THREADSAFE" != "0"; then
   AC_SEARCH_LIBS(pthread_create, pthread)
   AC_SEARCH_LIBS(pthread_mutexattr_init, pthread)
 fi
diff -ru sqlite-src-3260000/src/alter.c SQLumDash3.26.0/src/alter.c
--- sqlite-src-3260000/src/alter.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/alter.c	2019-01-16 11:03:54.000000000 +0900
@@ -159,6 +159,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK();
+
   /* Begin a transaction for database iDb. 
   ** Then modify the schema cookie (since the ALTER TABLE modifies the
   ** schema). Open a statement transaction if the table is a virtual
@@ -463,6 +465,8 @@
   pNew->addColOffset = pTab->addColOffset;
   pNew->nTabRef = 1;
 
+  ROWLOCK_TABLE_LOCK();
+
 exit_begin_add_column:
   sqlite3SrcListDelete(db, pSrc);
   return;
diff -ru sqlite-src-3260000/src/backup.c SQLumDash3.26.0/src/backup.c
--- sqlite-src-3260000/src/backup.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/backup.c	2019-04-15 16:44:03.000000000 +0900
@@ -402,6 +402,7 @@
                                                 (int*)&p->iDestSchema)) 
     ){
       p->bDestLocked = 1;
+      ROWLOCK_BACKUP_LOCK();
     }
 
     /* Do not allow backup if the destination database is in WAL mode
diff -ru sqlite-src-3260000/src/btree.c SQLumDash3.26.0/src/btree.c
--- sqlite-src-3260000/src/btree.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/btree.c	2019-04-15 16:39:40.000000000 +0900
@@ -165,7 +165,7 @@
 ** hold a write-lock on the schema table (root page 1). This is also
 ** acceptable.
 */
-static int hasSharedCacheTableLock(
+static int hasSharedCacheTableLockStatic(
   Btree *pBtree,         /* Handle that must hold lock */
   Pgno iRoot,            /* Root page of b-tree */
   int isIndex,           /* True if iRoot is the root of an index b-tree */
@@ -863,7 +863,7 @@
 ** Use the separate sqlite3BtreeCursorRestore() routine to restore a cursor
 ** back to where it ought to be if this routine returns true.
 */
-int sqlite3BtreeCursorHasMoved(BtCursor *pCur){
+int sqlite3BtreeCursorHasMovedOriginal(BtCursor *pCur){
   assert( EIGHT_BYTE_ALIGNMENT(pCur)
        || pCur==sqlite3BtreeFakeValidCursor() );
   assert( offsetof(BtCursor, eState)==0 );
@@ -895,7 +895,7 @@
 ** This routine should only be called for a cursor that just returned
 ** TRUE from sqlite3BtreeCursorHasMoved().
 */
-int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){
+int sqlite3BtreeCursorRestoreOriginal(BtCursor *pCur, int *pDifferentRow){
   int rc;
 
   assert( pCur!=0 );
@@ -2260,7 +2260,7 @@
 ** objects in the same database connection since doing so will lead
 ** to problems with locking.
 */
-int sqlite3BtreeOpen(
+int sqlite3BtreeOpenOriginal(
   sqlite3_vfs *pVfs,      /* VFS to use for this b-tree */
   const char *zFilename,  /* Name of the file containing the BTree database */
   sqlite3 *db,            /* Associated database handle */
@@ -2633,7 +2633,7 @@
 /*
 ** Close an open database and invalidate all cursors.
 */
-int sqlite3BtreeClose(Btree *p){
+int sqlite3BtreeCloseOriginal(Btree *p){
   BtShared *pBt = p->pBt;
   BtCursor *pCur;
 
@@ -3300,7 +3300,7 @@
 ** when A already has a read lock, we encourage A to give up and let B
 ** proceed.
 */
-int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){
+int sqlite3BtreeBeginTransOriginal(Btree *p, int wrflag, int *pSchemaVersion){
   BtShared *pBt = p->pBt;
   int rc = SQLITE_OK;
 
@@ -3785,7 +3785,7 @@
 ** SQLITE_DONE is returned. If it is not finished, but no error occurred,
 ** SQLITE_OK is returned. Otherwise an SQLite error code. 
 */
-int sqlite3BtreeIncrVacuum(Btree *p){
+int sqlite3BtreeIncrVacuumOriginal(Btree *p){
   int rc;
   BtShared *pBt = p->pBt;
 
@@ -3911,6 +3911,7 @@
   if( p->inTrans==TRANS_WRITE ){
     BtShared *pBt = p->pBt;
     sqlite3BtreeEnter(p);
+    ROWLOCK_TRANS_BTREE_COMMIT(p);
 #ifndef SQLITE_OMIT_AUTOVACUUM
     if( pBt->autoVacuum ){
       rc = autoVacuumCommit(pBt);
@@ -4103,7 +4104,7 @@
 ** This will release the write lock on the database file.  If there
 ** are no active cursors, it also releases the read lock.
 */
-int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){
+int sqlite3BtreeRollbackOriginal(Btree *p, int tripCode, int writeOnly){
   int rc;
   BtShared *pBt = p->pBt;
   MemPage *pPage1;
@@ -4172,7 +4173,7 @@
 ** iStatement is 1. This anonymous savepoint can be released or rolled back
 ** using the sqlite3BtreeSavepoint() function.
 */
-int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
+int sqlite3BtreeBeginStmtOriginal(Btree *p, int iStatement){
   int rc;
   BtShared *pBt = p->pBt;
   sqlite3BtreeEnter(p);
@@ -4203,7 +4204,7 @@
 ** from a normal transaction rollback, as no locks are released and the
 ** transaction remains open.
 */
-int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){
+int sqlite3BtreeSavepointOriginal(Btree *p, int op, int iSavepoint){
   int rc = SQLITE_OK;
   if( p && p->inTrans==TRANS_WRITE ){
     BtShared *pBt = p->pBt;
@@ -4335,7 +4336,7 @@
   pCur->eState = CURSOR_INVALID;
   return SQLITE_OK;
 }
-int sqlite3BtreeCursor(
+int sqlite3BtreeCursorOriginal(
   Btree *p,                                   /* The btree */
   int iTable,                                 /* Root page of table to open */
   int wrFlag,                                 /* 1 to write. 0 read-only */
@@ -4381,7 +4382,7 @@
 ** Close a cursor.  The read lock on the database file is released
 ** when the last cursor is closed.
 */
-int sqlite3BtreeCloseCursor(BtCursor *pCur){
+int sqlite3BtreeCloseCursorOriginal(BtCursor *pCur){
   Btree *pBtree = pCur->pBtree;
   if( pBtree ){
     BtShared *pBt = pCur->pBt;
@@ -4449,7 +4450,7 @@
 ** that is currently pointing to a row in a (non-empty) table.
 ** This is a verification routine is used only within assert() statements.
 */
-int sqlite3BtreeCursorIsValid(BtCursor *pCur){
+int sqlite3BtreeCursorIsValidOriginal(BtCursor *pCur){
   return pCur && pCur->eState==CURSOR_VALID;
 }
 #endif /* NDEBUG */
@@ -4464,7 +4465,7 @@
 ** ordinary table btree.  If the cursor points to an index btree or
 ** is invalid, the result of this routine is undefined.
 */
-i64 sqlite3BtreeIntegerKey(BtCursor *pCur){
+i64 sqlite3BtreeIntegerKeyOriginal(BtCursor *pCur){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->curIntKey );
@@ -4495,7 +4496,7 @@
 ** valid entry.  In other words, the calling procedure must guarantee
 ** that the cursor has Cursor.eState==CURSOR_VALID.
 */
-u32 sqlite3BtreePayloadSize(BtCursor *pCur){
+u32 sqlite3BtreePayloadSizeOriginal(BtCursor *pCur){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   getCellInfo(pCur);
@@ -4839,7 +4840,7 @@
 ** wrong.  An error is returned if "offset+amt" is larger than
 ** the available payload.
 */
-int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
+int sqlite3BtreePayloadOriginal(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->iPage>=0 && pCur->pPage );
@@ -4935,7 +4936,7 @@
 ** These routines is used to get quick access to key and data
 ** in the common case where no overflow pages are used.
 */
-const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt){
+const void *sqlite3BtreePayloadFetchOriginal(BtCursor *pCur, u32 *pAmt){
   return fetchPayload(pCur, pAmt);
 }
 
@@ -5198,7 +5199,7 @@
 ** sqlite3BtreeNext() is a no-op.
 */
 #ifndef SQLITE_OMIT_WINDOWFUNC
-void sqlite3BtreeSkipNext(BtCursor *pCur){
+void sqlite3BtreeSkipNextOriginal(BtCursor *pCur){
   /* We believe that the cursor must always be in the valid state when
   ** this routine is called, but the proof is difficult, so we add an
   ** ALWaYS() test just in case we are wrong. */
@@ -8902,7 +8903,7 @@
   *piTable = (int)pgnoRoot;
   return SQLITE_OK;
 }
-int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){
+int sqlite3BtreeCreateTableOriginal(Btree *p, int *piTable, int flags){
   int rc;
   sqlite3BtreeEnter(p);
   rc = btreeCreateTable(p, piTable, flags);
@@ -9111,7 +9112,7 @@
 #endif
   return rc;  
 }
-int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
+int sqlite3BtreeDropTableOriginal(Btree *p, int iTable, int *piMoved){
   int rc;
   sqlite3BtreeEnter(p);
   rc = btreeDropTable(p, iTable, piMoved);
@@ -9170,7 +9171,7 @@
 ** Write meta-information back into the database.  Meta[0] is
 ** read-only and may not be written.
 */
-int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
+int sqlite3BtreeUpdateMetaOriginal(Btree *p, int idx, u32 iMeta){
   BtShared *pBt = p->pBt;
   unsigned char *pP1;
   int rc;
@@ -9937,7 +9938,7 @@
 /*
 ** Return non-zero if a transaction is active.
 */
-int sqlite3BtreeIsInTrans(Btree *p){
+int sqlite3BtreeIsInTransOriginal(Btree *p){
   assert( p==0 || sqlite3_mutex_held(p->db->mutex) );
   return (p && (p->inTrans==TRANS_WRITE));
 }
@@ -10035,7 +10036,7 @@
 ** lock is a write lock if isWritelock is true or a read lock
 ** if it is false.
 */
-int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){
+int sqlite3BtreeLockTableOriginal(Btree *p, int iTab, u8 isWriteLock){
   int rc = SQLITE_OK;
   assert( p->inTrans!=TRANS_NONE );
   if( p->sharable ){
@@ -10124,7 +10125,7 @@
 ** "write version" (single byte at byte offset 19) fields in the database
 ** header to iVersion.
 */
-int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
+int sqlite3BtreeSetVersionOriginal(Btree *pBtree, int iVersion){
   BtShared *pBt = pBtree->pBt;
   int rc;                         /* Return code */
  
@@ -10193,3 +10194,9 @@
   return p->pBt->nRef;
 }
 #endif
+
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_BTREE_C
+#include "rowlock_btree.c"
+#undef SQLUMDASH_INCLUDED_FROM_BTREE_C
+#endif
\ ファイル末尾に改行がありません
diff -ru sqlite-src-3260000/src/btree.h SQLumDash3.26.0/src/btree.h
--- sqlite-src-3260000/src/btree.h	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/btree.h	2018-09-26 12:01:22.000000000 +0900
@@ -16,6 +16,10 @@
 #ifndef SQLITE_BTREE_H
 #define SQLITE_BTREE_H
 
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock_macro.h"
+#endif
+
 /* TODO: This definition is just included so other modules compile. It
 ** needs to be revisited.
 */
diff -ru sqlite-src-3260000/src/btreeInt.h SQLumDash3.26.0/src/btreeInt.h
--- sqlite-src-3260000/src/btreeInt.h	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/btreeInt.h	2018-12-20 13:19:11.000000000 +0900
@@ -214,7 +214,9 @@
 **      *     zero or more pages numbers of leaves
 */
 #include "sqliteInt.h"
-
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /* The following value is the maximum cell size assuming a maximum page
 ** size give above.
@@ -319,6 +321,11 @@
 /* Candidate values for BtLock.eLock */
 #define READ_LOCK     1
 #define WRITE_LOCK    2
+#ifndef SQLITE_OMIT_ROWLOCK
+#define WRITEEX_LOCK  3
+#define EXCLSV_LOCK   4
+#define NOT_LOCKED    0
+#endif
 
 /* A Btree handle
 **
@@ -356,6 +363,9 @@
 #ifndef SQLITE_OMIT_SHARED_CACHE
   BtLock lock;       /* Object used to lock page 1 */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  BtreeTrans btTrans;
+#endif
 };
 
 /*
@@ -508,6 +518,11 @@
   Btree *pBtree;            /* The Btree to which this cursor belongs */
   Pgno *aOverflow;          /* Cache of overflow page locations */
   void *pKey;               /* Saved key that was cursor last known position */
+#ifndef SQLITE_OMIT_ROWLOCK
+  BtCursorTrans btCurTrans;
+  i64 cachedRowid;
+  u8 autoRowid;
+#endif
   /* All fields above are zeroed when the cursor is allocated.  See
   ** sqlite3BtreeCursorZero().  Fields that follow must be manually
   ** initialized. */
diff -ru sqlite-src-3260000/src/build.c SQLumDash3.26.0/src/build.c
--- sqlite-src-3260000/src/build.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/build.c	2019-01-16 11:03:54.000000000 +0900
@@ -2733,6 +2733,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK();
+  
   /* Generate code to remove the table from the master table
   ** on disk.
   */
@@ -3700,6 +3702,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK_FOR_INDEX();
+
   /* Generate code to remove the index and from the master table */
   v = sqlite3GetVdbe(pParse);
   if( v ){
diff -ru sqlite-src-3260000/src/func.c SQLumDash3.26.0/src/func.c
--- sqlite-src-3260000/src/func.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/func.c	2018-09-26 12:01:22.000000000 +0900
@@ -17,6 +17,7 @@
 #include <stdlib.h>
 #include <assert.h>
 #include "vdbeInt.h"
+#include "funcNew.h"
 
 /*
 ** Return the collating function associated with a function.
@@ -1989,6 +1990,7 @@
     FUNCTION(coalesce,           1, 0, 0, 0                ),
     FUNCTION(coalesce,           0, 0, 0, 0                ),
     FUNCTION2(coalesce,         -1, 0, 0, noopFunc,  SQLITE_FUNC_COALESCE),
+    SQLUMDASH_NEW_FUNCTIONS,
   };
 #ifndef SQLITE_OMIT_ALTERTABLE
   sqlite3AlterFunctions();
SQLumDash3.26.0/src のみに存在: funcNew.c
SQLumDash3.26.0/src のみに存在: funcNew.h
diff -ru sqlite-src-3260000/src/global.c SQLumDash3.26.0/src/global.c
--- sqlite-src-3260000/src/global.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/global.c	2019-01-16 11:03:54.000000000 +0900
@@ -243,6 +243,10 @@
    0,                         /* bInternalFunctions */
    0x7ffffffe,                /* iOnceResetThreshold */
    SQLITE_DEFAULT_SORTERREF_SIZE   /* szSorterRef */
+#ifndef SQLITE_OMIT_ROWLOCK
+   ,ROWLOCK_DEFAULT_MMAP_ROW_SIZE, /* szMmapRowLock */
+   ROWLOCK_DEFAULT_MMAP_TABLE_SIZE /* szMmapTableLock */
+#endif
 };
 
 /*
diff -ru sqlite-src-3260000/src/main.c SQLumDash3.26.0/src/main.c
--- sqlite-src-3260000/src/main.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/main.c	2019-01-16 11:03:54.000000000 +0900
@@ -163,6 +163,10 @@
   */
   if( sqlite3GlobalConfig.isInit ) return SQLITE_OK;
 
+#ifdef SQLITE_TEST
+  ROWLOCK_INIT;
+#endif
+
   /* Make sure the mutex subsystem is initialized.  If unable to 
   ** initialize the mutex subsystem, return early with the error.
   ** If the system is so sick that we are unable to allocate a mutex,
@@ -641,6 +645,8 @@
       sqlite3GlobalConfig.nStmtSpill = va_arg(ap, int);
       break;
     }
+    
+    ROWLOCK_MMAP_CONFIG
 
 #ifdef SQLITE_ENABLE_SORTER_REFERENCES
     case SQLITE_CONFIG_SORTERREF_SIZE: {
@@ -1002,7 +1008,7 @@
 ** database handle object, it does not close any savepoints that may be open
 ** at the b-tree/pager level.
 */
-void sqlite3CloseSavepoints(sqlite3 *db){
+void sqlite3CloseSavepointsOriginal(sqlite3 *db){
   while( db->pSavepoint ){
     Savepoint *pTmp = db->pSavepoint;
     db->pSavepoint = pTmp->pNext;
@@ -4350,3 +4356,9 @@
   return 0;
 }
 #endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
+
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_MAIN_C
+#include "rowlock_main.c"
+#undef SQLUMDASH_INCLUDED_FROM_MAIN_C
+#endif
\ ファイル末尾に改行がありません
diff -ru sqlite-src-3260000/src/pager.c SQLumDash3.26.0/src/pager.c
--- sqlite-src-3260000/src/pager.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/pager.c	2019-01-16 11:03:54.000000000 +0900
@@ -859,6 +859,12 @@
 # define pagerBeginReadTransaction(z) SQLITE_OK
 #endif
 
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_PAGER_C
+#include "rowlock_pager.c"
+#undef SQLUMDASH_INCLUDED_FROM_PAGER_C
+#endif
+
 #ifndef NDEBUG 
 /*
 ** Usage:
@@ -868,7 +874,8 @@
 ** This function runs many asserts to try to find inconsistencies in
 ** the internal state of the Pager object.
 */
-static int assert_pager_state(Pager *p){
+static int assert_pager_state(Pager *p);
+static int assert_pager_state_original(Pager *p){
   Pager *pPager = p;
 
   /* State must be valid. */
@@ -3932,7 +3939,7 @@
 */
 static int pager_wait_on_lock(Pager *pPager, int locktype){
   int rc;                              /* Return code */
-
+  ROWLOCK_WAIT_ON_EXCLUSIVE_LOCK();
   /* Check that this is either a no-op (because the requested lock is 
   ** already held), or one of the transitions that the busy-handler
   ** may be invoked during, according to the comment above
@@ -4408,7 +4415,8 @@
 ** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot
 ** be obtained, SQLITE_BUSY is returned.
 */
-static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
+static int pager_write_pagelist(Pager *pPager, PgHdr *pList);
+static int pager_write_pagelist_original(Pager *pPager, PgHdr *pList){
   int rc = SQLITE_OK;                  /* Return code */
 
   /* This function is only called for rollback pagers in WRITER_DBMOD state. */
SQLumDash3.26.0/src のみに存在: rowlock.c
SQLumDash3.26.0/src のみに存在: rowlock.h
SQLumDash3.26.0/src のみに存在: rowlock_btree.c
SQLumDash3.26.0/src のみに存在: rowlock_hash.c
SQLumDash3.26.0/src のみに存在: rowlock_hash.h
SQLumDash3.26.0/src のみに存在: rowlock_ipc.c
SQLumDash3.26.0/src のみに存在: rowlock_ipc.h
SQLumDash3.26.0/src のみに存在: rowlock_ipc_row.c
SQLumDash3.26.0/src のみに存在: rowlock_ipc_row.h
SQLumDash3.26.0/src のみに存在: rowlock_ipc_table.c
SQLumDash3.26.0/src のみに存在: rowlock_ipc_table.h
SQLumDash3.26.0/src のみに存在: rowlock_macro.h
SQLumDash3.26.0/src のみに存在: rowlock_main.c
SQLumDash3.26.0/src のみに存在: rowlock_os.h
SQLumDash3.26.0/src のみに存在: rowlock_os_linux.c
SQLumDash3.26.0/src のみに存在: rowlock_os_linux.h
SQLumDash3.26.0/src のみに存在: rowlock_os_win.c
SQLumDash3.26.0/src のみに存在: rowlock_os_win.h
SQLumDash3.26.0/src のみに存在: rowlock_pager.c
SQLumDash3.26.0/src のみに存在: rowlock_savepoint.c
SQLumDash3.26.0/src のみに存在: rowlock_savepoint.h
diff -ru sqlite-src-3260000/src/sqlite.h.in SQLumDash3.26.0/src/sqlite.h.in
--- sqlite-src-3260000/src/sqlite.h.in	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/sqlite.h.in	2019-01-16 11:03:54.000000000 +0900
@@ -9322,6 +9322,39 @@
 # undef double
 #endif
 
+/* The followings are additional config flag for sqlite3_config. */
+#define SQLITE_CONFIG_MMAP_ROW_SIZE      28  /* int nByte */
+#define SQLITE_CONFIG_MMAP_TABLE_SIZE    29  /* int nByte */
+
+/* New error code for SQLumDash. */
+#define SQLITE_CORRUPT_ROWID 99 /* rowid issued automatically is corrupted. */
+
+/* For cleanup tool */
+void sqlite3_rowlock_ipc_unlock_record_all(const char *name);
+void sqlite3_rowlock_ipc_unlock_tables_all(const char *name);
+
+/* For the test */
+typedef struct IpcHandle IpcHandle;
+int sqlite3_rowlock_ipc_init(IpcHandle *pHandle, sqlite3_uint64 nByteRow, sqlite3_uint64 nByteTable, const void *owner, const char *name);
+void sqlite3_rowlock_ipc_finish(IpcHandle *pHandle);
+int sqlite3_rowlock_ipc_lock_record(IpcHandle *pHandle, int iTable, sqlite3_int64 rowid);
+void sqlite3_rowlock_ipc_unlock_record(IpcHandle *pHandle, int iTable, sqlite3_int64 rowid);
+void sqlite3_rowlock_ipc_unlock_record_proc(IpcHandle *pHandle, const char *name);
+int sqlite3_rowlock_ipc_lock_table(IpcHandle *pHandle, int iTable, unsigned char eLock, unsigned char *prevLock);
+unsigned char sqlite3_rowlock_ipc_lock_table_query(IpcHandle *pHandle, int iTable);
+void sqlite3_rowlock_ipc_unlock_table(IpcHandle *pHandle, int iTable);
+void sqlite3_rowlock_ipc_register_hash_func(int iClass, sqlite3_uint64(*xFunc)(void *pMap, ...));
+typedef struct RowLockSavepoint RowLockSavepoint;
+int sqlite3_rowlock_savepoint_init(RowLockSavepoint *pLockSavepoint);
+void sqlite3_rowlock_savepoint(RowLockSavepoint *pLockSavepoint, int op, int iSavepoint, IpcHandle *pHandle, void *pRootPages);
+void sqlite3_rowlock_savepoint_close(RowLockSavepoint *pLockSavepoint);
+int sqlite3_rowlock_savepoint_create(RowLockSavepoint *pLockSavepoint, int iSavepoint);
+int sqlite3_rowlock_history_add_record(RowLockSavepoint *pLockSavepoint, int iTable, sqlite3_int64 rowid);
+int sqlite3_rowlock_history_add_new_table(RowLockSavepoint *pLockSavepoint, int iTable);
+int sqlite3_rowlock_history_add_table_lock(RowLockSavepoint *pLockSavepoint, int iTable, unsigned char prevLock);
+void sqlite3_rowlock_register_unlockRecord_func(void(*xFunc)(IpcHandle*,int,sqlite3_int64));
+void sqlite3_rowlock_register_lockTable_func(int(*xFunc)(IpcHandle*,int,unsigned char));
+void sqlite3_rowlock_register_rootPageDel_func(void*(*xFunc)(void*,sqlite3_int64,void*));
 #ifdef __cplusplus
 }  /* End of the 'extern "C"' block */
 #endif
diff -ru sqlite-src-3260000/src/sqliteInt.h SQLumDash3.26.0/src/sqliteInt.h
--- sqlite-src-3260000/src/sqliteInt.h	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/sqliteInt.h	2019-04-18 13:44:03.000000000 +0900
@@ -1493,6 +1493,9 @@
 #ifdef SQLITE_USER_AUTHENTICATION
   sqlite3_userauth auth;        /* User authentication information */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  u8 inOpTrans;
+#endif
 };
 
 /*
@@ -3421,6 +3424,10 @@
   int bInternalFunctions;           /* Internal SQL functions are visible */
   int iOnceResetThreshold;          /* When to reset OP_Once counters */
   u32 szSorterRef;                  /* Min size in bytes to use sorter-refs */
+#ifndef SQLITE_OMIT_ROWLOCK
+  sqlite3_int64 szMmapRowLock;      /* MMAP space for row lock */
+  sqlite3_int64 szMmapTableLock;    /* MMAP space for table lock */
+#endif
 };
 
 /*
SQLumDash3.26.0/src のみに存在: test4_new.c
SQLumDash3.26.0/src のみに存在: test_rowlock.c
diff -ru sqlite-src-3260000/src/test_tclsh.c SQLumDash3.26.0/src/test_tclsh.c
--- sqlite-src-3260000/src/test_tclsh.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/test_tclsh.c	2018-12-21 09:19:36.000000000 +0900
@@ -62,11 +62,13 @@
   extern int Sqlitetest2_Init(Tcl_Interp*);
   extern int Sqlitetest3_Init(Tcl_Interp*);
   extern int Sqlitetest4_Init(Tcl_Interp*);
+  extern int Sqlitetest4_new_Init(Tcl_Interp*);
   extern int Sqlitetest5_Init(Tcl_Interp*);
   extern int Sqlitetest6_Init(Tcl_Interp*);
   extern int Sqlitetest7_Init(Tcl_Interp*);
   extern int Sqlitetest8_Init(Tcl_Interp*);
   extern int Sqlitetest9_Init(Tcl_Interp*);
+  extern int Sqlitetest_rowlock_Init(Tcl_Interp*);
   extern int Sqlitetestasync_Init(Tcl_Interp*);
   extern int Sqlitetest_autoext_Init(Tcl_Interp*);
   extern int Sqlitetest_blob_Init(Tcl_Interp*);
@@ -131,11 +133,13 @@
   Sqlitetest2_Init(interp);
   Sqlitetest3_Init(interp);
   Sqlitetest4_Init(interp);
+  Sqlitetest4_new_Init(interp);
   Sqlitetest5_Init(interp);
   Sqlitetest6_Init(interp);
   Sqlitetest7_Init(interp);
   Sqlitetest8_Init(interp);
   Sqlitetest9_Init(interp);
+  Sqlitetest_rowlock_Init(interp);
   Sqlitetestasync_Init(interp);
   Sqlitetest_autoext_Init(interp);
   Sqlitetest_blob_Init(interp);
diff -ru sqlite-src-3260000/src/trigger.c SQLumDash3.26.0/src/trigger.c
--- sqlite-src-3260000/src/trigger.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/trigger.c	2018-09-26 12:01:23.000000000 +0900
@@ -628,6 +628,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK_FOR_TRIGGER();
+
   /* Generate code to destroy the database record of the trigger.
   */
   assert( pTable!=0 );
diff -ru sqlite-src-3260000/src/vacuum.c SQLumDash3.26.0/src/vacuum.c
--- sqlite-src-3260000/src/vacuum.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/vacuum.c	2019-04-15 16:34:18.000000000 +0900
@@ -17,6 +17,8 @@
 #include "sqliteInt.h"
 #include "vdbeInt.h"
 
+#include "rowlock.h"
+
 #if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)
 
 /*
@@ -223,9 +225,16 @@
   ** file. This is done before the sqlite3BtreeGetPageSize(pMain) call below,
   ** to ensure that we do not try to change the page-size on a WAL database.
   */
+#ifndef SQLITE_OMIT_ROWLOCK
+  ROWLOCK_VACUM_LOCK(pMain);
+#endif
   rc = execSql(db, pzErrMsg, "BEGIN");
   if( rc!=SQLITE_OK ) goto end_of_vacuum;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeBeginTransOriginal(pMain, 2, 0);
+#else
   rc = sqlite3BtreeBeginTrans(pMain, 2, 0);
+#endif
   if( rc!=SQLITE_OK ) goto end_of_vacuum;
 
   /* Do not attempt to change the page size for a WAL database */
diff -ru sqlite-src-3260000/src/vdbe.c SQLumDash3.26.0/src/vdbe.c
--- sqlite-src-3260000/src/vdbe.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/vdbe.c	2019-06-11 17:16:39.000000000 +0900
@@ -20,6 +20,9 @@
 */
 #include "sqliteInt.h"
 #include "vdbeInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /*
 ** Invoke this macro on memory cells just prior to changing the
@@ -979,7 +982,7 @@
 case OP_Halt: {
   VdbeFrame *pFrame;
   int pcx;
-
+  ROWLOCK_SET_FORCE_COMMIT(p);
   pcx = (int)(pOp - aOp);
 #ifdef SQLITE_DEBUG
   if( pOp->p2==OE_Abort ){ sqlite3VdbeAssertAbortable(p); }
@@ -1398,7 +1401,15 @@
   ** The statement transaction is never a top-level transaction.  Hence
   ** the RELEASE call below can never fail.
   */
+#ifndef SQLITE_OMIT_ROWLOCK
+  /* Rowlock feature enables statement journal for write transaction
+  ** including sqlite3_open_blob(). In this case, iStatement becomes
+  ** non-zero value.
+  */
+  assert( p->iStatement==0 || db->flags&SQLITE_CountRows || p->usesStmtJournal );
+#else
   assert( p->iStatement==0 || db->flags&SQLITE_CountRows );
+#endif
   rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE);
   assert( rc==SQLITE_OK );
 
@@ -3016,6 +3027,7 @@
                                 db->nStatement+db->nSavepoint);
       if( rc!=SQLITE_OK ) goto abort_due_to_error;
 #endif
+      ROWLOCK_SAVEPOINT_CREATE();
 
       /* Create a new savepoint structure. */
       pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint)+nName+1);
@@ -3268,7 +3280,7 @@
       }
       goto abort_due_to_error;
     }
-
+    ROWLOCK_ENABLE_STMT_JOURNAL();
     if( pOp->p2 && p->usesStmtJournal 
      && (db->autoCommit==0 || db->nVdbeRead>1) 
     ){
@@ -3290,6 +3302,7 @@
       p->nStmtDefCons = db->nDeferredCons;
       p->nStmtDefImmCons = db->nDeferredImmCons;
     }
+    ROWLOCK_OP_TRANS_END();
   }
   assert( pOp->p5==0 || pOp->p4type==P4_INT32 );
   if( pOp->p5
@@ -3585,6 +3598,7 @@
   sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
                                (pOp->p5 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));
   if( rc ) goto abort_due_to_error;
+  ROWLOCK_CACHED_ROWID_SET_BY_OPEN_CURSOR();
   break;
 }
 
@@ -3968,7 +3982,11 @@
         if( (oc & 0x0001)==(OP_SeekLT & 0x0001) ) oc++;
       }
     } 
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, 0, (u64)iKey, 0, &res, pOp->opcode);
+#else
     rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);
+#endif
     pC->movetoTarget = iKey;  /* Used by OP_Delete */
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
@@ -4012,7 +4030,11 @@
     { int i; for(i=0; i<r.nField; i++) assert( memIsValid(&r.aMem[i]) ); }
 #endif
     r.eqSeen = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, &r, 0, 0, &res, pOp->opcode);
+#else
     rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, &r, 0, 0, &res);
+#endif
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
     }
@@ -4248,7 +4270,11 @@
       }
     }
   }
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, pIdxKey, 0, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);
+#endif
   if( pFree ) sqlite3DbFreeNN(db, pFree);
   if( rc!=SQLITE_OK ){
     goto abort_due_to_error;
@@ -4350,7 +4376,11 @@
   assert( pCrsr!=0 );
   res = 0;
   iKey = pIn3->u.i;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pCrsr, 0, iKey, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
+#endif
   assert( rc==SQLITE_OK || res==0 );
   pC->movetoTarget = iKey;  /* Used by OP_Delete */
   pC->nullRow = 0;
@@ -4446,7 +4476,11 @@
 #   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
 #endif
 
+    ROWLOCK_CACHED_ROWID_FLAG_SET();
     if( !pC->useRandomRowid ){
+#ifndef SQLITE_OMIT_ROWLOCK
+      ROWLOCK_CACHED_ROWID_NEW_ROWID();
+#else
       rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
       if( rc!=SQLITE_OK ){
         goto abort_due_to_error;
@@ -4462,6 +4496,7 @@
           v++;   /* IMP: R-29538-34987 */
         }
       }
+#endif
     }
 
 #ifndef SQLITE_OMIT_AUTOINCREMENT
@@ -4505,8 +4540,13 @@
       do{
         sqlite3_randomness(sizeof(v), &v);
         v &= (MAX_ROWID>>1); v++;  /* Ensure that v is greater than zero */
+#ifndef SQLITE_OMIT_ROWLOCK
+      }while(  ((rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, 0, (u64)v,
+                                                 0, &res, pOp->opcode))==SQLITE_OK)
+#else
       }while(  ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,
                                                  0, &res))==SQLITE_OK)
+#endif
             && (res==0)
             && (++cnt<100));
       if( rc ) goto abort_due_to_error;
@@ -4520,6 +4560,7 @@
     pC->cacheStatus = CACHE_STALE;
   }
   pOut->u.i = v;
+  ROWLOCK_CACHED_ROWID_SET();
   break;
 }
 
@@ -4594,6 +4635,7 @@
     assert( memIsValid(pKey) );
     REGISTER_TRACE(pOp->p3, pKey);
     x.nKey = pKey->u.i;
+    ROWLOCK_CACHED_ROWID_UPDATE();
   }else{
     assert( pOp->opcode==OP_InsertInt );
     x.nKey = pOp->p3;
@@ -4635,9 +4677,15 @@
     x.nZero = 0;
   }
   x.pKey = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeInsert(pC->uc.pCursor, &x,
+      (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult
+  );
+#else
   rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult
   );
+#endif
   pC->deferredMoveto = 0;
   pC->cacheStatus = CACHE_STALE;
 
@@ -4766,7 +4814,11 @@
   }
 #endif
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeDelete(pC->uc.pCursor, pOp->p5);
+#else
   rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);
+#endif
   pC->cacheStatus = CACHE_STALE;
   pC->seekResult = 0;
   if( rc ) goto abort_due_to_error;
@@ -5152,7 +5204,11 @@
     assert( pC->eCurType==CURTYPE_BTREE );
     pCrsr = pC->uc.pCursor;
     assert( pCrsr );
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeFirstAll(pCrsr, &res);
+#else
     rc = sqlite3BtreeFirst(pCrsr, &res);
+#endif
 #ifndef SQLITE_OMIT_WINDOWFUNC
     if( pOp->p5 ) sqlite3BtreeSkipNext(pCrsr);
 #endif
@@ -5256,7 +5312,11 @@
        || pC->seekOp==OP_Last 
        || pC->seekOp==OP_NullRow);
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeAdvanceAll(pC->uc.pCursor, pOp->p3, pOp->p4.xAdvance);
+#else
   rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
+#endif
 next_tail:
   pC->cacheStatus = CACHE_STALE;
   VdbeBranchTaken(rc==SQLITE_OK,2);
@@ -5333,10 +5393,17 @@
     x.pKey = pIn2->z;
     x.aMem = aMem + pOp->p3;
     x.nMem = (u16)pOp->p4.i;
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3TransBtreeInsert(pC->uc.pCursor, &x,
+         (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), 
+        ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
+        );
+#else
     rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
          (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), 
         ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
         );
+#endif
     assert( pC->deferredMoveto==0 );
     pC->cacheStatus = CACHE_STALE;
   }
@@ -5371,10 +5438,18 @@
   r.nField = (u16)pOp->p3;
   r.default_rc = 0;
   r.aMem = &aMem[pOp->p2];
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pCrsr, &r, 0, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
+#endif
   if( rc ) goto abort_due_to_error;
   if( res==0 ){
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3TransBtreeDelete(pCrsr, BTREE_AUXDELETE);
+#else
     rc = sqlite3BtreeDelete(pCrsr, BTREE_AUXDELETE);
+#endif
     if( rc ) goto abort_due_to_error;
   }
   assert( pC->deferredMoveto==0 );
@@ -5605,7 +5680,11 @@
     iDb = pOp->p3;
     assert( DbMaskTest(p->btreeMask, iDb) );
     iMoved = 0;  /* Not needed.  Only to silence a warning. */
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeDropTableAll(db->aDb[iDb].pBt, pOp->p1, &iMoved);
+#else
     rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
+#endif
     pOut->flags = MEM_Int;
     pOut->u.i = iMoved;
     if( rc ) goto abort_due_to_error;
@@ -5646,9 +5725,15 @@
   nChange = 0;
   assert( p->readOnly==0 );
   assert( DbMaskTest(p->btreeMask, pOp->p2) );
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeClearTable(
+      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
+  );
+#else
   rc = sqlite3BtreeClearTable(
       db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
   );
+#endif
   if( pOp->p3 ){
     p->nChange += nChange;
     if( pOp->p3>0 ){
@@ -6770,7 +6855,11 @@
     int p1 = pOp->p1; 
     assert( p1>=0 && p1<db->nDb );
     assert( DbMaskTest(p->btreeMask, p1) );
+#ifndef SQLITE_OMIT_ROWLOCK
+    assert( isWriteLock==0 || isWriteLock==1 || isWriteLock==2 );
+#else
     assert( isWriteLock==0 || isWriteLock==1 );
+#endif
     rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
     if( rc ){
       if( (rc&0xFF)==SQLITE_LOCKED ){
@@ -6779,6 +6868,8 @@
       }
       goto abort_due_to_error;
     }
+    rc = rowlockBtreeCacheReset(db->aDb[p1].pBt);
+    if( rc ) goto abort_due_to_error;
   }
   break;
 }
diff -ru sqlite-src-3260000/src/vdbeInt.h SQLumDash3.26.0/src/vdbeInt.h
--- sqlite-src-3260000/src/vdbeInt.h	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/vdbeInt.h	2019-05-08 10:34:55.000000000 +0900
@@ -421,6 +421,10 @@
   int nScan;              /* Entries in aScan[] */
   ScanStatus *aScan;      /* Scan definitions for sqlite3_stmt_scanstatus() */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  u8 forceCommit;         /* True for statements that do commit forcibly by DDL */
+  u8 stmtJournalEnabled;  /* True if usesStmtJournal is enabled by the execution */
+#endif
 };
 
 /*
diff -ru sqlite-src-3260000/src/vdbeapi.c SQLumDash3.26.0/src/vdbeapi.c
--- sqlite-src-3260000/src/vdbeapi.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/vdbeapi.c	2019-01-16 11:03:55.000000000 +0900
@@ -16,6 +16,8 @@
 #include "sqliteInt.h"
 #include "vdbeInt.h"
 
+ROWLOCK_CACHED_ROWID_RETRY
+
 #ifndef SQLITE_OMIT_DEPRECATED
 /*
 ** Return TRUE (non-zero) of the statement supplied as an argument needs
@@ -543,7 +545,7 @@
 ** schema change has occurred.  That detail is handled by the
 ** outer sqlite3_step() wrapper procedure.
 */
-static int sqlite3Step(Vdbe *p){
+static int sqlite3StepOriginal(Vdbe *p){
   sqlite3 *db;
   int rc;
 
diff -ru sqlite-src-3260000/src/vdbeaux.c SQLumDash3.26.0/src/vdbeaux.c
--- sqlite-src-3260000/src/vdbeaux.c	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/src/vdbeaux.c	2019-01-16 11:03:55.000000000 +0900
@@ -14,6 +14,9 @@
 */
 #include "sqliteInt.h"
 #include "vdbeInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /*
 ** Create a new virtual database engine.
@@ -2388,7 +2391,7 @@
   */ 
   for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ 
     Btree *pBt = db->aDb[i].pBt;
-    if( sqlite3BtreeIsInTrans(pBt) ){
+    if( sqlite3BtreeIsInTransOriginal(pBt) ){
       /* Whether or not a database might need a master journal depends upon
       ** its journal mode (among other things).  This matrix determines which
       ** journal modes use a master journal and which do not */
@@ -2839,6 +2842,11 @@
           }
           rc = SQLITE_CONSTRAINT_FOREIGNKEY;
         }else{ 
+#ifndef SQLITE_OMIT_ROWLOCK
+          rc = sqlite3BtreeBeginTransForCommit(db);
+          if( rc ) return rc;
+#endif
+
           /* The auto-commit flag is true, the vdbe program was successful 
           ** or hit an 'OR FAIL' constraint and there are no deferred foreign
           ** key constraints to hold up the transaction. This means a commit 
@@ -2913,6 +2921,10 @@
     sqlite3VdbeLeave(p);
   }
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  ROWLOCK_VDBE_HALT(p);
+#endif
+
   /* We have successfully halted and closed the VM.  Record this fact. */
   if( p->pc>=0 ){
     db->nVdbeActive--;
@@ -3219,7 +3231,11 @@
   assert( p->deferredMoveto );
   assert( p->isTable );
   assert( p->eCurType==CURTYPE_BTREE );
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(p->uc.pCursor, 0, p->movetoTarget, 0, &res, 0);
+#else
   rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);
+#endif
   if( rc ) return rc;
   if( res!=0 ) return SQLITE_CORRUPT_BKPT;
 #ifdef SQLITE_TEST
diff -ru sqlite-src-3260000/test/permutations.test SQLumDash3.26.0/test/permutations.test
--- sqlite-src-3260000/test/permutations.test	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/test/permutations.test	2019-01-16 11:03:55.000000000 +0900
@@ -912,6 +912,25 @@
   test_set $::allquicktests shared_err.test -exclude async3.test
 ]
 
+#List of test that need huge MMap
+# select2.test
+# speed4.test
+test_suite "SQLumdash-huge-mmap-testsuite" -description {
+  Run test that need large MMap for much step in a transaction
+} -initialize {
+  catch {db close}
+  sqlite3_shutdown
+  catch {sqlite3_rowlock_config_mmap CONFIG_ROWLOCK_MMAP_SIZE 52428800}
+  sqlite3_initialize
+} -files {
+  select2.test
+} -shutdown {
+  catch {db close}
+  sqlite3_shutdown
+  catch {sqlite3_rowlock_config_mmap CONFIG_ROWLOCK_MMAP_SIZE 1048576}
+  sqlite3_initialize
+}
+
 # The set of tests to run on the alternative-pcache
 set perm-alt-pcache-testset {
   async.test
SQLumDash3.26.0/test のみに存在: rowlock_common.tcl
SQLumDash3.26.0/test のみに存在: sqlumdash_huge_mmap_testsuite.test
diff -ru sqlite-src-3260000/test/tester.tcl SQLumDash3.26.0/test/tester.tcl
--- sqlite-src-3260000/test/tester.tcl	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/test/tester.tcl	2019-01-16 11:03:55.000000000 +0900
@@ -527,6 +527,13 @@
         set cmdlinearg(verbose) 2
       }
 
+
+      # add switch mode
+      {^-+mode=.+$} {
+        foreach {dummy cmdlinearg(switchmode)} [split $a =] break
+        set ::G(switchmode) $cmdlinearg(switchmode)
+      }
+
       default {
         if {[file tail $a]==$a} {
           lappend leftover $a
diff -ru sqlite-src-3260000/tool/mksqlite3c-noext.tcl SQLumDash3.26.0/tool/mksqlite3c-noext.tcl
--- sqlite-src-3260000/tool/mksqlite3c-noext.tcl	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/tool/mksqlite3c-noext.tcl	2018-12-21 10:27:05.000000000 +0900
@@ -119,6 +119,16 @@
    vxworks.h
    wal.h
    whereInt.h
+   rowlock.h
+   rowlock_hash.h
+   rowlock_ipc.h
+   rowlock_ipc_row.h
+   rowlock_ipc_table.h
+   rowlock_macro.h
+   rowlock_os.h
+   rowlock_os_linux.h
+   rowlock_os_win.h
+   rowlock_savepoint.h
 } {
   set available_hdr($hdr) 1
 }
@@ -336,6 +346,7 @@
    callback.c
    delete.c
    func.c
+   funcNew.c
    fkey.c
    insert.c
    legacy.c
@@ -353,6 +364,18 @@
    where.c
    window.c
 
+   rowlock.c
+   rowlock_btree.c
+   rowlock_hash.c
+   rowlock_ipc.c
+   rowlock_ipc_row.c
+   rowlock_ipc_table.c
+   rowlock_main.c
+   rowlock_os_linux.c
+   rowlock_os_win.c
+   rowlock_pager.c
+   rowlock_savepoint.c
+
    parse.c
 
    tokenize.c
diff -ru sqlite-src-3260000/tool/mksqlite3c.tcl SQLumDash3.26.0/tool/mksqlite3c.tcl
--- sqlite-src-3260000/tool/mksqlite3c.tcl	2018-12-01 20:38:18.000000000 +0900
+++ SQLumDash3.26.0/tool/mksqlite3c.tcl	2018-12-21 10:27:05.000000000 +0900
@@ -127,6 +127,16 @@
    vxworks.h
    wal.h
    whereInt.h
+   rowlock.h
+   rowlock_hash.h
+   rowlock_ipc.h
+   rowlock_ipc_row.h
+   rowlock_ipc_table.h
+   rowlock_macro.h
+   rowlock_os.h
+   rowlock_os_linux.h
+   rowlock_os_win.h
+   rowlock_savepoint.h
 } {
   set available_hdr($hdr) 1
 }
@@ -354,6 +364,7 @@
    callback.c
    delete.c
    func.c
+   funcNew.c
    fkey.c
    insert.c
    legacy.c
@@ -372,6 +383,18 @@
    where.c
    window.c
 
+   rowlock.c
+   rowlock_btree.c
+   rowlock_hash.c
+   rowlock_ipc.c
+   rowlock_ipc_row.c
+   rowlock_ipc_table.c
+   rowlock_main.c
+   rowlock_os_linux.c
+   rowlock_os_win.c
+   rowlock_pager.c
+   rowlock_savepoint.c
+
    parse.c
 
    tokenize.c
SQLumDash3.26.0/tool のみに存在: rowlock_cleaner.c
SQLumDash3.26.0/tool/win のみに存在: uniq.bat
