diff -ru sqlite-src-3280000/Makefile.in SQLumDash3.28.0/Makefile.in
--- sqlite-src-3280000/Makefile.in	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/Makefile.in	2019-08-21 14:50:23.000000000 +0900
@@ -70,6 +70,9 @@
 #
 TLIBS = @LIBS@ $(LIBS)
 
+# Add libm for new functions of SQLumDash
+TLIBS += -lm
+
 # Flags controlling use of the in memory btree implementation
 #
 # SQLITE_TEMP_STORE is 0 to force temporary tables to be in a file, 1 to
@@ -178,7 +181,7 @@
          fts3_tokenize_vtab.lo \
          fts3_unicode.lo fts3_unicode2.lo fts3_write.lo \
 	 fts5.lo \
-         func.lo global.lo hash.lo \
+         func.lo funcNew.lo global.lo hash.lo \
          icu.lo insert.lo json1.lo legacy.lo loadext.lo \
          main.lo malloc.lo mem0.lo mem1.lo mem2.lo mem3.lo mem5.lo \
          memdb.lo memjournal.lo \
@@ -191,7 +194,10 @@
          update.lo userauth.lo upsert.lo util.lo vacuum.lo \
          vdbe.lo vdbeapi.lo vdbeaux.lo vdbeblob.lo vdbemem.lo vdbesort.lo \
          vdbetrace.lo wal.lo walker.lo where.lo wherecode.lo whereexpr.lo \
-         window.lo utf.lo vtab.lo
+         window.lo utf.lo vtab.lo \
+         rowlock.lo rowlock_hash.lo rowlock_ipc.lo rowlock_ipc_row.lo \
+         rowlock_ipc_table.lo rowlock_os_linux.lo rowlock_savepoint.lo \
+         rowlock_vdbeblob.lo rowlock_vtab.lo
 
 # Object files for the amalgamation.
 #
@@ -227,6 +233,7 @@
   $(TOP)/src/fault.c \
   $(TOP)/src/fkey.c \
   $(TOP)/src/func.c \
+  $(TOP)/src/funcNew.c \
   $(TOP)/src/global.c \
   $(TOP)/src/hash.c \
   $(TOP)/src/hash.h \
@@ -308,6 +315,33 @@
   $(TOP)/src/whereInt.h \
   $(TOP)/src/window.c
 
+# Source code for SQLumDash
+#
+SRC += \
+  $(TOP)/src/rowlock.c \
+  $(TOP)/src/rowlock.h \
+  $(TOP)/src/rowlock_btree.c \
+  $(TOP)/src/rowlock_hash.c \
+  $(TOP)/src/rowlock_hash.h \
+  $(TOP)/src/rowlock_ipc.c \
+  $(TOP)/src/rowlock_ipc.h \
+  $(TOP)/src/rowlock_ipc_row.c \
+  $(TOP)/src/rowlock_ipc_row.h \
+  $(TOP)/src/rowlock_ipc_table.c \
+  $(TOP)/src/rowlock_ipc_table.h \
+  $(TOP)/src/rowlock_macro.h \
+  $(TOP)/src/rowlock_main.c \
+  $(TOP)/src/rowlock_os.h \
+  $(TOP)/src/rowlock_os_linux.c \
+  $(TOP)/src/rowlock_os_linux.h \
+  $(TOP)/src/rowlock_os_win.c \
+  $(TOP)/src/rowlock_os_win.h \
+  $(TOP)/src/rowlock_pager.c \
+  $(TOP)/src/rowlock_savepoint.c \
+  $(TOP)/src/rowlock_savepoint.h \
+  $(TOP)/src/rowlock_vdbeblob.c \
+  $(TOP)/src/rowlock_vtab.c
+  
 # Source code for extensions
 #
 SRC += \
@@ -385,11 +419,13 @@
   $(TOP)/src/test2.c \
   $(TOP)/src/test3.c \
   $(TOP)/src/test4.c \
+  $(TOP)/src/test4_new.c \
   $(TOP)/src/test5.c \
   $(TOP)/src/test6.c \
   $(TOP)/src/test7.c \
   $(TOP)/src/test8.c \
   $(TOP)/src/test9.c \
+  $(TOP)/src/test_rowlock.c \
   $(TOP)/src/test_autoext.c \
   $(TOP)/src/test_async.c \
   $(TOP)/src/test_backup.c \
@@ -478,6 +514,7 @@
   $(TOP)/src/dbstat.c \
   $(TOP)/src/expr.c \
   $(TOP)/src/func.c \
+  $(TOP)/src/funcNew.c \
   $(TOP)/src/global.c \
   $(TOP)/src/insert.c \
   $(TOP)/src/wal.c \
@@ -506,6 +543,16 @@
   $(TOP)/src/wherecode.c \
   $(TOP)/src/whereexpr.c \
   $(TOP)/src/window.c \
+  $(TOP)/src/rowlock.c \
+  $(TOP)/src/rowlock_hash.c \
+  $(TOP)/src/rowlock_ipc.c \
+  $(TOP)/src/rowlock_ipc_row.c \
+  $(TOP)/src/rowlock_ipc_table.c \
+  $(TOP)/src/rowlock_os_linux.c \
+  $(TOP)/src/rowlock_os_win.c \
+  $(TOP)/src/rowlock_savepoint.c \
+  $(TOP)/src/rowlock_vdbeblob.c \
+  $(TOP)/src/rowlock_vtab.c \
   parse.c \
   $(TOP)/ext/fts3/fts3.c \
   $(TOP)/ext/fts3/fts3_aux.c \
@@ -522,6 +569,7 @@
 HDR = \
    $(TOP)/src/btree.h \
    $(TOP)/src/btreeInt.h \
+   $(TOP)/src/funcNew.h \
    $(TOP)/src/hash.h \
    $(TOP)/src/hwtime.h \
    keywordhash.h \
@@ -544,6 +592,16 @@
    $(TOP)/src/vdbeInt.h \
    $(TOP)/src/vxworks.h \
    $(TOP)/src/whereInt.h \
+   $(TOP)/src/rowlock.h \
+   $(TOP)/src/rowlock_hash.h \
+   $(TOP)/src/rowlock_ipc.h \
+   $(TOP)/src/rowlock_ipc_row.h \
+   $(TOP)/src/rowlock_ipc_table.h \
+   $(TOP)/src/rowlock_macro.h \
+   $(TOP)/src/rowlock_os.h \
+   $(TOP)/src/rowlock_os_linux.h \
+   $(TOP)/src/rowlock_os_win.h \
+   $(TOP)/src/rowlock_savepoint.h \
    config.h
 
 # Header files used by extensions
@@ -626,7 +684,7 @@
 # This is the default Makefile target.  The objects listed here
 # are what get build when you type just "make" with no arguments.
 #
-all:	sqlite3.h libsqlite3.la sqlite3$(TEXE) $(HAVE_TCL:1=libtclsqlite3.la)
+all:	sqlite3.h libsqlite3.la sqlite3$(TEXE) $(HAVE_TCL:1=libtclsqlite3.la) sqlumdash_cleaner
 
 Makefile: $(TOP)/Makefile.in
 	./config.status
@@ -855,6 +913,9 @@
 func.lo:	$(TOP)/src/func.c $(HDR)
 	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/func.c
 
+funcNew.lo:	$(TOP)/src/funcNew.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/funcNew.c
+
 global.lo:	$(TOP)/src/global.c $(HDR)
 	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/global.c
 
@@ -1026,6 +1087,33 @@
 window.lo:	$(TOP)/src/window.c $(HDR)
 	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/window.c
 
+rowlock.lo:	$(TOP)/src/rowlock.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock.c
+
+rowlock_hash.lo:	$(TOP)/src/rowlock_hash.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_hash.c
+
+rowlock_ipc.lo:	$(TOP)/src/rowlock_ipc.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_ipc.c
+
+rowlock_ipc_row.lo:	$(TOP)/src/rowlock_ipc_row.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_ipc_row.c
+
+rowlock_ipc_table.lo:	$(TOP)/src/rowlock_ipc_table.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_ipc_table.c
+
+rowlock_os_linux.lo:	$(TOP)/src/rowlock_os_linux.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_os_linux.c
+
+rowlock_savepoint.lo:	$(TOP)/src/rowlock_savepoint.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_savepoint.c
+
+rowlock_vdbeblob.lo:	$(TOP)/src/rowlock_vdbeblob.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_vdbeblob.c
+
+rowlock_vtab.lo:	$(TOP)/src/rowlock_vtab.c $(HDR)
+	$(LTCOMPILE) $(TEMP_STORE) -c $(TOP)/src/rowlock_vtab.c
+
 tclsqlite.lo:	$(TOP)/src/tclsqlite.c $(HDR)
 	$(LTCOMPILE) -DUSE_TCL_STUBS=1 -c $(TOP)/src/tclsqlite.c
 
@@ -1082,6 +1170,14 @@
 
 
 
+# Rules to build the cleanup tool of lowlock
+#
+CLEANER_SRC = \
+	$(TOP)/tool/rowlock_cleaner.c
+
+sqlumdash_cleaner:	 $(CLEANER_SRC) libsqlite3.la sqlite3.h
+	$(TCC) -o sqlumdash_cleaner -I$(TOP) -L.libs -lsqlite3 $(OPT_FEATURE_FLAGS) $(OPTS) $(CLEANER_SRC)
+
 # Rules to build the extension objects.
 #
 icu.lo:	$(TOP)/ext/icu/icu.c $(HDR) $(EXTHDR)
@@ -1457,6 +1553,8 @@
 	rm -f sqldiff sqldiff.exe
 	rm -f dbhash dbhash.exe
 	rm -f fts5.* fts5parse.*
+	rm -f sqlumdash_cleaner sqlumdash_cleaner
+
 
 distclean:	clean
 	rm -f config.h config.log config.status libtool Makefile sqlite3.pc
diff -ru sqlite-src-3280000/Makefile.msc SQLumDash3.28.0/Makefile.msc
--- sqlite-src-3280000/Makefile.msc	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/Makefile.msc	2019-08-21 14:32:44.000000000 +0900
@@ -966,8 +966,8 @@
 
 # Should the database engine be compiled threadsafe
 #
-TCC = $(TCC) -DSQLITE_THREADSAFE=1
-RCC = $(RCC) -DSQLITE_THREADSAFE=1
+TCC = $(TCC) -DSQLITE_THREADSAFE=2
+RCC = $(RCC) -DSQLITE_THREADSAFE=2
 
 # Do threads override each others locks by default (1), or do we test (-1)
 #
@@ -980,6 +980,8 @@
 TLIBS =
 !ENDIF
 
+TLIBS = $(TLIBS) advapi32.lib
+
 # Flags controlling use of the in memory btree implementation
 #
 # SQLITE_TEMP_STORE is 0 to force temporary tables to be in a file, 1 to
@@ -1176,6 +1178,9 @@
 !ENDIF
 !ENDIF
 
+# Add linking library for MMAP.
+LTLINKOPTS = $(LTLINKOPTS) advapi32.lib
+
 # If either debugging or symbols are enabled, enable PDBs.
 #
 !IF $(DEBUG)>1 || $(SYMBOLS)!=0
@@ -1222,7 +1227,7 @@
          fts3_porter.lo fts3_snippet.lo fts3_tokenizer.lo fts3_tokenizer1.lo \
          fts3_tokenize_vtab.lo fts3_unicode.lo fts3_unicode2.lo fts3_write.lo \
          fts5.lo \
-         func.lo global.lo hash.lo \
+         func.lo funcNew.lo global.lo hash.lo \
          icu.lo insert.lo json1.lo legacy.lo loadext.lo \
          main.lo malloc.lo mem0.lo mem1.lo mem2.lo mem3.lo mem5.lo \
          memdb.lo memjournal.lo \
@@ -1235,7 +1240,10 @@
          update.lo upsert.lo util.lo vacuum.lo \
          vdbeapi.lo vdbeaux.lo vdbeblob.lo vdbemem.lo vdbesort.lo \
          vdbetrace.lo wal.lo walker.lo where.lo wherecode.lo whereexpr.lo \
-         window.lo utf.lo vtab.lo
+         window.lo utf.lo vtab.lo \
+         rowlock.lo rowlock_hash.lo rowlock_ipc.lo rowlock_ipc_row.lo \
+         rowlock_ipc_table.lo rowlock_os_win.lo rowlock_savepoint.lo \
+         rowlock_vdbeblob.lo rowlock_vtab.lo
 # <</mark>>
 
 # Object files for the amalgamation.
@@ -1286,6 +1294,7 @@
   $(TOP)\src\fault.c \
   $(TOP)\src\fkey.c \
   $(TOP)\src\func.c \
+  $(TOP)\src\funcNew.c \
   $(TOP)\src\global.c \
   $(TOP)\src\hash.c \
   $(TOP)\src\insert.c \
@@ -1347,7 +1356,20 @@
   $(TOP)\src\where.c \
   $(TOP)\src\wherecode.c \
   $(TOP)\src\whereexpr.c \
-  $(TOP)\src\window.c
+  $(TOP)\src\window.c \
+  $(TOP)\src\rowlock.c \
+  $(TOP)\src\rowlock_btree.c \
+  $(TOP)\src\rowlock_hash.c \
+  $(TOP)\src\rowlock_ipc.c \
+  $(TOP)\src\rowlock_ipc_row.c \
+  $(TOP)\src\rowlock_ipc_table.c \
+  $(TOP)\src\rowlock_main.c \
+  $(TOP)\src\rowlock_os_linux.c \
+  $(TOP)\src\rowlock_os_win.c \
+  $(TOP)\src\rowlock_pager.c \
+  $(TOP)\src\rowlock_savepoint.c \
+  $(TOP)\src\rowlock_vdbeblob.c \
+  $(TOP)\src\rowlock_vtab.c
 
 # Core miscellaneous files.
 #
@@ -1359,6 +1381,7 @@
 SRC04 = \
   $(TOP)\src\btree.h \
   $(TOP)\src\btreeInt.h \
+  $(TOP)\src\funcNew.h \
   $(TOP)\src\hash.h \
   $(TOP)\src\hwtime.h \
   $(TOP)\src\msvc.h \
@@ -1382,7 +1405,17 @@
   $(TOP)\src\vdbeInt.h \
   $(TOP)\src\vxworks.h \
   $(TOP)\src\wal.h \
-  $(TOP)\src\whereInt.h
+  $(TOP)\src\whereInt.h \
+  $(TOP)\src\rowlock.h \
+  $(TOP)\src\rowlock_hash.h \
+  $(TOP)\src\rowlock_ipc.h \
+  $(TOP)\src\rowlock_ipc_row.h \
+  $(TOP)\src\rowlock_ipc_table.h \
+  $(TOP)\src\rowlock_macro.h \
+  $(TOP)\src\rowlock_os.h \
+  $(TOP)\src\rowlock_os_linux.h \
+  $(TOP)\src\rowlock_os_win.h \
+  $(TOP)\src\rowlock_savepoint.h
 
 # Extension source code files, part 1.
 #
@@ -1480,11 +1513,13 @@
   $(TOP)\src\test2.c \
   $(TOP)\src\test3.c \
   $(TOP)\src\test4.c \
+  $(TOP)\src\test4_new.c \
   $(TOP)\src\test5.c \
   $(TOP)\src\test6.c \
   $(TOP)\src\test7.c \
   $(TOP)\src\test8.c \
   $(TOP)\src\test9.c \
+  $(TOP)\src\test_rowlock.c \
   $(TOP)\src\test_autoext.c \
   $(TOP)\src\test_async.c \
   $(TOP)\src\test_backup.c \
@@ -1600,7 +1635,16 @@
    $(TOP)\src\vdbe.h \
    $(TOP)\src\vdbeInt.h \
    $(TOP)\src\vxworks.h \
-   $(TOP)\src\whereInt.h
+   $(TOP)\src\whereInt.h \
+   $(TOP)\src\rowlock.h \
+   $(TOP)\src\rowlock_hash.h \
+   $(TOP)\src\rowlock_ipc.h \
+   $(TOP)\src\rowlock_ipc_row.h \
+   $(TOP)\src\rowlock_ipc_table.h \
+   $(TOP)\src\rowlock_macro.h \
+   $(TOP)\src\rowlock_os.h \
+   $(TOP)\src\rowlock_os_win.h \
+   $(TOP)\src\rowlock_savepoint.h
 
 # Header files used by extensions
 #
@@ -1695,7 +1739,7 @@
 # This is the default Makefile target.  The objects listed here
 # are what get build when you type just "make" with no arguments.
 #
-core:	dll libsqlite3.lib shell
+core:	dll libsqlite3.lib shell sqlumdash_cleaner.exe
 
 # Targets that require the Tcl library.
 #
@@ -1743,8 +1787,10 @@
 sqlite3.def:	libsqlite3.lib
 	echo EXPORTS > sqlite3.def
 	dumpbin /all libsqlite3.lib \
-		| $(TCLSH_CMD) $(TOP)\tool\replace.tcl include "^\s+1 _?(sqlite3(?:session|changeset|changegroup|rebaser)?_[^@]*)(?:@\d+)?$$" \1 \
-		| sort >> sqlite3.def
+		| $(TCLSH_CMD) $(TOP)\tool\replace.tcl include "^\s+[0-9A-F]+ _?(sqlite3(?:session|changeset|changegroup|rebaser)?_[^@]*)(?:@\d+)?$$" \1 \
+		| sort >> sqlite3.def.tmp
+	.\tool\win\uniq.bat sqlite3.def.tmp >> sqlite3.def
+	del sqlite3.def.tmp
 # <</block2>>
 
 $(SQLITE3EXE):	shell.c $(SHELL_CORE_DEP) $(LIBRESOBJS) $(SHELL_CORE_SRC) $(SQLITE3H)
@@ -1947,6 +1993,9 @@
 func.lo:	$(TOP)\src\func.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\func.c
 
+funcNew.lo:	$(TOP)\src\funcNew.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\funcNew.c
+
 global.lo:	$(TOP)\src\global.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\global.c
 
@@ -2118,6 +2167,33 @@
 window.lo:	$(TOP)\src\window.c $(HDR)
 	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\window.c
 
+rowlock.lo:	$(TOP)\src\rowlock.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock.c
+
+rowlock_hash.lo:	$(TOP)\src\rowlock_hash.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_hash.c
+
+rowlock_ipc.lo:	$(TOP)\src\rowlock_ipc.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc.c
+
+rowlock_ipc_row.lo:	$(TOP)\src\rowlock_ipc_row.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc_row.c
+
+rowlock_ipc_table.lo:	$(TOP)\src\rowlock_ipc_table.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_ipc_table.c
+
+rowlock_os_win.lo:	$(TOP)\src\rowlock_os_win.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_os_win.c
+
+rowlock_savepoint.lo:	$(TOP)\src\rowlock_savepoint.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_savepoint.c
+
+rowlock_vdbeblob.lo:	$(TOP)\src\rowlock_vdbeblob.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_vdbeblob.c
+
+rowlock_vtab.lo:	$(TOP)\src\rowlock_vtab.c $(HDR)
+	$(LTCOMPILE) $(CORE_COMPILE_OPTS) -c $(TOP)\src\rowlock_vtab.c
+
 tclsqlite.lo:	$(TOP)\src\tclsqlite.c $(HDR) $(SQLITE_TCL_DEP)
 	$(LTCOMPILE) $(NO_WARN) -DUSE_TCL_STUBS=1 -DBUILD_sqlite -I$(TCLINCDIR) -c $(TOP)\src\tclsqlite.c
 
@@ -2188,6 +2264,15 @@
 zlib:
 	pushd $(ZLIBDIR) && $(MAKE) /f win32\Makefile.msc clean $(ZLIBLIB) && popd
 
+# Rules to build the rowlock cleaner
+#
+CLEANER_SRC = \
+	$(TOP)\tool\rowlock_cleaner.c
+
+sqlumdash_cleaner.exe:	 $(CLEANER_SRC) $(SQLITE3H)
+	$(TCC) $(NO_WARN) -Fe$@ $(REQ_FEATURE_FLAGS) $(OPT_FEATURE_FLAGS) $(EXT_FEATURE_FLAGS) $(OPTS) \
+		$(CLEANER_SRC) /link $(LDFLAGS) $(NLTLINKOPTS) $(NLTLIBPATHS) $(SQLITE3LIB) $(TLIBS)
+
 # Rules to build the extension objects.
 #
 icu.lo:	$(TOP)\ext\icu\icu.c $(HDR) $(EXTHDR)
@@ -2578,4 +2663,5 @@
 	del /Q showshm.exe sqlite3_checker.* sqlite3_expert.exe 2>NUL
 	del /Q fts5.* fts5parse.* 2>NUL
 	del /Q lsm.h lsm1.c 2>NUL
+	del /Q sqlumdash_cleaner.exe 2>NUL
 # <</mark>>
sqlite-src-3280000 のみに存在: compat
diff -ru sqlite-src-3280000/configure.ac SQLumDash3.28.0/configure.ac
--- sqlite-src-3280000/configure.ac	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/configure.ac	2018-12-14 10:34:09.000000000 +0900
@@ -188,12 +188,12 @@
   SQLITE_THREADSAFE=0
   AC_MSG_RESULT([no])
 else
-  SQLITE_THREADSAFE=1
+  SQLITE_THREADSAFE=2
   AC_MSG_RESULT([yes])
 fi
 AC_SUBST(SQLITE_THREADSAFE)
 
-if test "$SQLITE_THREADSAFE" = "1"; then
+if test "$SQLITE_THREADSAFE" != "0"; then
   AC_SEARCH_LIBS(pthread_create, pthread)
   AC_SEARCH_LIBS(pthread_mutexattr_init, pthread)
 fi
diff -ru sqlite-src-3280000/src/alter.c SQLumDash3.28.0/src/alter.c
--- sqlite-src-3280000/src/alter.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/alter.c	2019-08-21 14:32:45.000000000 +0900
@@ -166,10 +166,13 @@
   }
 #endif
 
-  /* Begin a transaction for database iDb. Then modify the schema cookie
-  ** (since the ALTER TABLE modifies the schema). Call sqlite3MayAbort(),
-  ** as the scalar functions (e.g. sqlite_rename_table()) invoked by the 
-  ** nested SQL may raise an exception.  */
+  ROWLOCK_TABLE_LOCK_FOR_ALTER();
+
+  /* Begin a transaction for database iDb. 
+  ** Then modify the schema cookie (since the ALTER TABLE modifies the
+  ** schema). Open a statement transaction if the table is a virtual
+  ** table.
+  */
   v = sqlite3GetVdbe(pParse);
   if( v==0 ){
     goto exit_rename_table;
@@ -469,6 +472,8 @@
   pNew->addColOffset = pTab->addColOffset;
   pNew->nTabRef = 1;
 
+  ROWLOCK_TABLE_LOCK_FOR_ALTER();
+
 exit_begin_add_column:
   sqlite3SrcListDelete(db, pSrc);
   return;
@@ -559,6 +564,8 @@
     goto exit_rename_column;
   }
 
+  ROWLOCK_TABLE_LOCK_FOR_ALTER_IDB();
+
   /* Do the rename operation using a recursive UPDATE statement that
   ** uses the sqlite_rename_column() SQL function to compute the new
   ** CREATE statement text for the sqlite_master table.
diff -ru sqlite-src-3280000/src/backup.c SQLumDash3.28.0/src/backup.c
--- sqlite-src-3280000/src/backup.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/backup.c	2019-04-15 16:44:03.000000000 +0900
@@ -402,6 +402,7 @@
                                                 (int*)&p->iDestSchema)) 
     ){
       p->bDestLocked = 1;
+      ROWLOCK_BACKUP_LOCK();
     }
 
     /* Do not allow backup if the destination database is in WAL mode
diff -ru sqlite-src-3280000/src/btree.c SQLumDash3.28.0/src/btree.c
--- sqlite-src-3280000/src/btree.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/btree.c	2019-08-21 14:32:45.000000000 +0900
@@ -165,7 +165,7 @@
 ** hold a write-lock on the schema table (root page 1). This is also
 ** acceptable.
 */
-static int hasSharedCacheTableLock(
+static int hasSharedCacheTableLockStatic(
   Btree *pBtree,         /* Handle that must hold lock */
   Pgno iRoot,            /* Root page of b-tree */
   int isIndex,           /* True if iRoot is the root of an index b-tree */
@@ -874,7 +874,7 @@
 ** Use the separate sqlite3BtreeCursorRestore() routine to restore a cursor
 ** back to where it ought to be if this routine returns true.
 */
-int sqlite3BtreeCursorHasMoved(BtCursor *pCur){
+int sqlite3BtreeCursorHasMovedOriginal(BtCursor *pCur){
   assert( EIGHT_BYTE_ALIGNMENT(pCur)
        || pCur==sqlite3BtreeFakeValidCursor() );
   assert( offsetof(BtCursor, eState)==0 );
@@ -906,7 +906,7 @@
 ** This routine should only be called for a cursor that just returned
 ** TRUE from sqlite3BtreeCursorHasMoved().
 */
-int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){
+int sqlite3BtreeCursorRestoreOriginal(BtCursor *pCur, int *pDifferentRow){
   int rc;
 
   assert( pCur!=0 );
@@ -2320,7 +2320,7 @@
 ** objects in the same database connection since doing so will lead
 ** to problems with locking.
 */
-int sqlite3BtreeOpen(
+int sqlite3BtreeOpenOriginal(
   sqlite3_vfs *pVfs,      /* VFS to use for this b-tree */
   const char *zFilename,  /* Name of the file containing the BTree database */
   sqlite3 *db,            /* Associated database handle */
@@ -2693,7 +2693,7 @@
 /*
 ** Close an open database and invalidate all cursors.
 */
-int sqlite3BtreeClose(Btree *p){
+int sqlite3BtreeCloseOriginal(Btree *p){
   BtShared *pBt = p->pBt;
   BtCursor *pCur;
 
@@ -3361,7 +3361,7 @@
 ** when A already has a read lock, we encourage A to give up and let B
 ** proceed.
 */
-int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){
+int sqlite3BtreeBeginTransOriginal(Btree *p, int wrflag, int *pSchemaVersion){
   BtShared *pBt = p->pBt;
   int rc = SQLITE_OK;
 
@@ -3846,7 +3846,7 @@
 ** SQLITE_DONE is returned. If it is not finished, but no error occurred,
 ** SQLITE_OK is returned. Otherwise an SQLite error code. 
 */
-int sqlite3BtreeIncrVacuum(Btree *p){
+int sqlite3BtreeIncrVacuumOriginal(Btree *p){
   int rc;
   BtShared *pBt = p->pBt;
 
@@ -3972,6 +3972,7 @@
   if( p->inTrans==TRANS_WRITE ){
     BtShared *pBt = p->pBt;
     sqlite3BtreeEnter(p);
+    ROWLOCK_TRANS_BTREE_COMMIT(p);
 #ifndef SQLITE_OMIT_AUTOVACUUM
     if( pBt->autoVacuum ){
       rc = autoVacuumCommit(pBt);
@@ -4164,7 +4165,7 @@
 ** This will release the write lock on the database file.  If there
 ** are no active cursors, it also releases the read lock.
 */
-int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){
+int sqlite3BtreeRollbackOriginal(Btree *p, int tripCode, int writeOnly){
   int rc;
   BtShared *pBt = p->pBt;
   MemPage *pPage1;
@@ -4233,7 +4234,7 @@
 ** iStatement is 1. This anonymous savepoint can be released or rolled back
 ** using the sqlite3BtreeSavepoint() function.
 */
-int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
+int sqlite3BtreeBeginStmtOriginal(Btree *p, int iStatement){
   int rc;
   BtShared *pBt = p->pBt;
   sqlite3BtreeEnter(p);
@@ -4264,7 +4265,7 @@
 ** from a normal transaction rollback, as no locks are released and the
 ** transaction remains open.
 */
-int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){
+int sqlite3BtreeSavepointOriginal(Btree *p, int op, int iSavepoint){
   int rc = SQLITE_OK;
   if( p && p->inTrans==TRANS_WRITE ){
     BtShared *pBt = p->pBt;
@@ -4396,7 +4397,7 @@
   pCur->eState = CURSOR_INVALID;
   return SQLITE_OK;
 }
-int sqlite3BtreeCursor(
+int sqlite3BtreeCursorOriginal(
   Btree *p,                                   /* The btree */
   int iTable,                                 /* Root page of table to open */
   int wrFlag,                                 /* 1 to write. 0 read-only */
@@ -4442,7 +4443,7 @@
 ** Close a cursor.  The read lock on the database file is released
 ** when the last cursor is closed.
 */
-int sqlite3BtreeCloseCursor(BtCursor *pCur){
+int sqlite3BtreeCloseCursorOriginal(BtCursor *pCur){
   Btree *pBtree = pCur->pBtree;
   if( pBtree ){
     BtShared *pBt = pCur->pBt;
@@ -4511,7 +4512,7 @@
 ** that is currently pointing to a row in a (non-empty) table.
 ** This is a verification routine is used only within assert() statements.
 */
-int sqlite3BtreeCursorIsValid(BtCursor *pCur){
+int sqlite3BtreeCursorIsValidOriginal(BtCursor *pCur){
   return pCur && pCur->eState==CURSOR_VALID;
 }
 #endif /* NDEBUG */
@@ -4526,7 +4527,7 @@
 ** ordinary table btree.  If the cursor points to an index btree or
 ** is invalid, the result of this routine is undefined.
 */
-i64 sqlite3BtreeIntegerKey(BtCursor *pCur){
+i64 sqlite3BtreeIntegerKeyOriginal(BtCursor *pCur){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->curIntKey );
@@ -4557,7 +4558,7 @@
 ** valid entry.  In other words, the calling procedure must guarantee
 ** that the cursor has Cursor.eState==CURSOR_VALID.
 */
-u32 sqlite3BtreePayloadSize(BtCursor *pCur){
+u32 sqlite3BtreePayloadSizeOriginal(BtCursor *pCur){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   getCellInfo(pCur);
@@ -4920,7 +4921,7 @@
 ** wrong.  An error is returned if "offset+amt" is larger than
 ** the available payload.
 */
-int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
+int sqlite3BtreePayloadOriginal(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->iPage>=0 && pCur->pPage );
@@ -5016,7 +5017,7 @@
 ** These routines is used to get quick access to key and data
 ** in the common case where no overflow pages are used.
 */
-const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt){
+const void *sqlite3BtreePayloadFetchOriginal(BtCursor *pCur, u32 *pAmt){
   return fetchPayload(pCur, pAmt);
 }
 
@@ -5273,6 +5274,23 @@
   return rc;
 }
 
+/*
+** This function is a no-op if cursor pCur does not point to a valid row.
+** Otherwise, if pCur is valid, configure it so that the next call to
+** sqlite3BtreeNext() is a no-op.
+*/
+#ifndef SQLITE_OMIT_WINDOWFUNC
+void sqlite3BtreeSkipNextOriginal(BtCursor *pCur){
+  /* We believe that the cursor must always be in the valid state when
+  ** this routine is called, but the proof is difficult, so we add an
+  ** ALWaYS() test just in case we are wrong. */
+  if( ALWAYS(pCur->eState==CURSOR_VALID) ){
+    pCur->eState = CURSOR_SKIPNEXT;
+    pCur->skipNext = 1;
+  }
+}
+#endif /* SQLITE_OMIT_WINDOWFUNC */
+
 /* Move the cursor to the last entry in the table.  Return SQLITE_OK
 ** on success.  Set *pRes to 0 if the cursor actually points to something
 ** or set *pRes to 1 if the table is empty.
@@ -9126,7 +9144,7 @@
   *piTable = (int)pgnoRoot;
   return SQLITE_OK;
 }
-int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){
+int sqlite3BtreeCreateTableOriginal(Btree *p, int *piTable, int flags){
   int rc;
   sqlite3BtreeEnter(p);
   rc = btreeCreateTable(p, piTable, flags);
@@ -9229,7 +9247,7 @@
 **
 ** This routine only work for pCur on an ephemeral table.
 */
-int sqlite3BtreeClearTableOfCursor(BtCursor *pCur){
+int sqlite3BtreeClearTableOfCursorOriginal(BtCursor *pCur){
   return sqlite3BtreeClearTable(pCur->pBtree, pCur->pgnoRoot, 0);
 }
 
@@ -9338,7 +9356,7 @@
 #endif
   return rc;  
 }
-int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
+int sqlite3BtreeDropTableOriginal(Btree *p, int iTable, int *piMoved){
   int rc;
   sqlite3BtreeEnter(p);
   rc = btreeDropTable(p, iTable, piMoved);
@@ -9397,7 +9415,7 @@
 ** Write meta-information back into the database.  Meta[0] is
 ** read-only and may not be written.
 */
-int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
+int sqlite3BtreeUpdateMetaOriginal(Btree *p, int idx, u32 iMeta){
   BtShared *pBt = p->pBt;
   unsigned char *pP1;
   int rc;
@@ -9430,7 +9448,7 @@
 ** Otherwise, if an error is encountered (i.e. an IO error or database
 ** corruption) an SQLite error code is returned.
 */
-int sqlite3BtreeCount(BtCursor *pCur, i64 *pnEntry){
+int sqlite3BtreeCountOriginal(BtCursor *pCur, i64 *pnEntry){
   i64 nEntry = 0;                      /* Value to return in *pnEntry */
   int rc;                              /* Return code */
 
@@ -10169,7 +10187,7 @@
 /*
 ** Return non-zero if a transaction is active.
 */
-int sqlite3BtreeIsInTrans(Btree *p){
+int sqlite3BtreeIsInTransOriginal(Btree *p){
   assert( p==0 || sqlite3_mutex_held(p->db->mutex) );
   return (p && (p->inTrans==TRANS_WRITE));
 }
@@ -10267,7 +10285,7 @@
 ** lock is a write lock if isWritelock is true or a read lock
 ** if it is false.
 */
-int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){
+int sqlite3BtreeLockTableOriginal(Btree *p, int iTab, u8 isWriteLock){
   int rc = SQLITE_OK;
   assert( p->inTrans!=TRANS_NONE );
   if( p->sharable ){
@@ -10356,7 +10374,7 @@
 ** "write version" (single byte at byte offset 19) fields in the database
 ** header to iVersion.
 */
-int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
+int sqlite3BtreeSetVersionOriginal(Btree *pBtree, int iVersion){
   BtShared *pBt = pBtree->pBt;
   int rc;                         /* Return code */
  
@@ -10425,3 +10443,9 @@
   return p->pBt->nRef;
 }
 #endif
+
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_BTREE_C
+#include "rowlock_btree.c"
+#undef SQLUMDASH_INCLUDED_FROM_BTREE_C
+#endif
\ ファイル末尾に改行がありません
diff -ru sqlite-src-3280000/src/btree.h SQLumDash3.28.0/src/btree.h
--- sqlite-src-3280000/src/btree.h	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/btree.h	2019-08-21 14:32:45.000000000 +0900
@@ -16,6 +16,10 @@
 #ifndef SQLITE_BTREE_H
 #define SQLITE_BTREE_H
 
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock_macro.h"
+#endif
+
 /* TODO: This definition is just included so other modules compile. It
 ** needs to be revisited.
 */
diff -ru sqlite-src-3280000/src/btreeInt.h SQLumDash3.28.0/src/btreeInt.h
--- sqlite-src-3280000/src/btreeInt.h	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/btreeInt.h	2019-08-21 14:32:45.000000000 +0900
@@ -214,7 +214,9 @@
 **      *     zero or more pages numbers of leaves
 */
 #include "sqliteInt.h"
-
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /* The following value is the maximum cell size assuming a maximum page
 ** size give above.
@@ -319,6 +321,11 @@
 /* Candidate values for BtLock.eLock */
 #define READ_LOCK     1
 #define WRITE_LOCK    2
+#ifndef SQLITE_OMIT_ROWLOCK
+#define WRITEEX_LOCK  3
+#define EXCLSV_LOCK   4
+#define NOT_LOCKED    0
+#endif
 
 /* A Btree handle
 **
@@ -356,6 +363,9 @@
 #ifndef SQLITE_OMIT_SHARED_CACHE
   BtLock lock;       /* Object used to lock page 1 */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  BtreeTrans btTrans;
+#endif
 };
 
 /*
@@ -515,6 +525,11 @@
   Btree *pBtree;            /* The Btree to which this cursor belongs */
   Pgno *aOverflow;          /* Cache of overflow page locations */
   void *pKey;               /* Saved key that was cursor last known position */
+#ifndef SQLITE_OMIT_ROWLOCK
+  BtCursorTrans btCurTrans;
+  i64 cachedRowid;
+  u8 autoRowid;
+#endif
   /* All fields above are zeroed when the cursor is allocated.  See
   ** sqlite3BtreeCursorZero().  Fields that follow must be manually
   ** initialized. */
diff -ru sqlite-src-3280000/src/build.c SQLumDash3.28.0/src/build.c
--- sqlite-src-3280000/src/build.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/build.c	2019-08-21 14:32:45.000000000 +0900
@@ -2746,6 +2746,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK();
+  
   /* Generate code to remove the table from the master table
   ** on disk.
   */
@@ -3725,6 +3727,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK_FOR_INDEX();
+
   /* Generate code to remove the index and from the master table */
   v = sqlite3GetVdbe(pParse);
   if( v ){
diff -ru sqlite-src-3280000/src/func.c SQLumDash3.28.0/src/func.c
--- sqlite-src-3280000/src/func.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/func.c	2019-08-21 14:32:45.000000000 +0900
@@ -17,6 +17,7 @@
 #include <stdlib.h>
 #include <assert.h>
 #include "vdbeInt.h"
+#include "funcNew.h"
 
 /*
 ** Return the collating function associated with a function.
@@ -1997,6 +1998,7 @@
     FUNCTION(coalesce,           1, 0, 0, 0                ),
     FUNCTION(coalesce,           0, 0, 0, 0                ),
     FUNCTION2(coalesce,         -1, 0, 0, noopFunc,  SQLITE_FUNC_COALESCE),
+    SQLUMDASH_NEW_FUNCTIONS,
   };
 #ifndef SQLITE_OMIT_ALTERTABLE
   sqlite3AlterFunctions();
SQLumDash3.28.0/src のみに存在: funcNew.c
SQLumDash3.28.0/src のみに存在: funcNew.h
diff -ru sqlite-src-3280000/src/global.c SQLumDash3.28.0/src/global.c
--- sqlite-src-3280000/src/global.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/global.c	2019-08-21 13:47:08.000000000 +0900
@@ -252,7 +252,11 @@
    0,                         /* bLocaltimeFault */
    0,                         /* bInternalFunctions */
    0x7ffffffe,                /* iOnceResetThreshold */
-   SQLITE_DEFAULT_SORTERREF_SIZE,   /* szSorterRef */
+   SQLITE_DEFAULT_SORTERREF_SIZE   /* szSorterRef */
+#ifndef SQLITE_OMIT_ROWLOCK
+   ,ROWLOCK_DEFAULT_MMAP_ROW_SIZE, /* szMmapRowLock */
+   ROWLOCK_DEFAULT_MMAP_TABLE_SIZE /* szMmapTableLock */
+#endif
 };
 
 /*
diff -ru sqlite-src-3280000/src/main.c SQLumDash3.28.0/src/main.c
--- sqlite-src-3280000/src/main.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/main.c	2019-08-21 14:32:45.000000000 +0900
@@ -15,6 +15,9 @@
 ** accessed by users of the library.
 */
 #include "sqliteInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 #ifdef SQLITE_ENABLE_FTS3
 # include "fts3.h"
@@ -163,6 +166,10 @@
   */
   if( sqlite3GlobalConfig.isInit ) return SQLITE_OK;
 
+#ifdef SQLITE_TEST
+  ROWLOCK_INIT;
+#endif
+
   /* Make sure the mutex subsystem is initialized.  If unable to 
   ** initialize the mutex subsystem, return early with the error.
   ** If the system is so sick that we are unable to allocate a mutex,
@@ -641,6 +648,8 @@
       sqlite3GlobalConfig.nStmtSpill = va_arg(ap, int);
       break;
     }
+    
+    ROWLOCK_MMAP_CONFIG
 
 #ifdef SQLITE_ENABLE_SORTER_REFERENCES
     case SQLITE_CONFIG_SORTERREF_SIZE: {
@@ -1011,7 +1020,7 @@
 ** database handle object, it does not close any savepoints that may be open
 ** at the b-tree/pager level.
 */
-void sqlite3CloseSavepoints(sqlite3 *db){
+void sqlite3CloseSavepointsOriginal(sqlite3 *db){
   while( db->pSavepoint ){
     Savepoint *pTmp = db->pSavepoint;
     db->pSavepoint = pTmp->pNext;
@@ -1124,6 +1133,8 @@
     return SQLITE_BUSY;
   }
 
+  RWOLOCK_DB_CLOSE(db);
+
 #ifdef SQLITE_ENABLE_SQLLOG
   if( sqlite3GlobalConfig.xSqllog ){
     /* Closing the handle. Fourth parameter is passed the value 2. */
@@ -4382,3 +4393,9 @@
   return 0;
 }
 #endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
+
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_MAIN_C
+#include "rowlock_main.c"
+#undef SQLUMDASH_INCLUDED_FROM_MAIN_C
+#endif
\ ファイル末尾に改行がありません
diff -ru sqlite-src-3280000/src/pager.c SQLumDash3.28.0/src/pager.c
--- sqlite-src-3280000/src/pager.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/pager.c	2019-08-21 14:32:45.000000000 +0900
@@ -862,6 +862,12 @@
 # define pagerBeginReadTransaction(z) SQLITE_OK
 #endif
 
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_PAGER_C
+#include "rowlock_pager.c"
+#undef SQLUMDASH_INCLUDED_FROM_PAGER_C
+#endif
+
 #ifndef NDEBUG 
 /*
 ** Usage:
@@ -871,7 +877,8 @@
 ** This function runs many asserts to try to find inconsistencies in
 ** the internal state of the Pager object.
 */
-static int assert_pager_state(Pager *p){
+static int assert_pager_state(Pager *p);
+static int assert_pager_state_original(Pager *p){
   Pager *pPager = p;
 
   /* State must be valid. */
@@ -3944,7 +3951,7 @@
 */
 static int pager_wait_on_lock(Pager *pPager, int locktype){
   int rc;                              /* Return code */
-
+  ROWLOCK_WAIT_ON_EXCLUSIVE_LOCK();
   /* Check that this is either a no-op (because the requested lock is 
   ** already held), or one of the transitions that the busy-handler
   ** may be invoked during, according to the comment above
@@ -4420,7 +4427,8 @@
 ** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot
 ** be obtained, SQLITE_BUSY is returned.
 */
-static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
+static int pager_write_pagelist(Pager *pPager, PgHdr *pList);
+static int pager_write_pagelist_original(Pager *pPager, PgHdr *pList){
   int rc = SQLITE_OK;                  /* Return code */
 
   /* This function is only called for rollback pagers in WRITER_DBMOD state. */
diff -ru sqlite-src-3280000/src/pragma.c SQLumDash3.28.0/src/pragma.c
--- sqlite-src-3280000/src/pragma.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/pragma.c	2019-08-21 13:46:14.000000000 +0900
@@ -1808,6 +1808,7 @@
       /* Write the specified cookie value */
       static const VdbeOpList setCookie[] = {
         { OP_Transaction,    0,  1,  0},    /* 0 */
+        ROWLOCK_SCVER_OPECODE_ADD,
         { OP_SetCookie,      0,  0,  0},    /* 1 */
       };
       VdbeOp *aOp;
@@ -1818,6 +1819,7 @@
       aOp[1].p1 = iDb;
       aOp[1].p2 = iCookie;
       aOp[1].p3 = sqlite3Atoi(zRight);
+      ROWLOCK_SCVER_OPECODE_MAKE();
     }else{
       /* Read the specified cookie value */
       static const VdbeOpList readCookie[] = {
SQLumDash3.28.0/src のみに存在: rowlock.c
SQLumDash3.28.0/src のみに存在: rowlock.h
SQLumDash3.28.0/src のみに存在: rowlock_btree.c
SQLumDash3.28.0/src のみに存在: rowlock_hash.c
SQLumDash3.28.0/src のみに存在: rowlock_hash.h
SQLumDash3.28.0/src のみに存在: rowlock_ipc.c
SQLumDash3.28.0/src のみに存在: rowlock_ipc.h
SQLumDash3.28.0/src のみに存在: rowlock_ipc_row.c
SQLumDash3.28.0/src のみに存在: rowlock_ipc_row.h
SQLumDash3.28.0/src のみに存在: rowlock_ipc_table.c
SQLumDash3.28.0/src のみに存在: rowlock_ipc_table.h
SQLumDash3.28.0/src のみに存在: rowlock_macro.h
SQLumDash3.28.0/src のみに存在: rowlock_main.c
SQLumDash3.28.0/src のみに存在: rowlock_os.h
SQLumDash3.28.0/src のみに存在: rowlock_os_linux.c
SQLumDash3.28.0/src のみに存在: rowlock_os_linux.h
SQLumDash3.28.0/src のみに存在: rowlock_os_win.c
SQLumDash3.28.0/src のみに存在: rowlock_os_win.h
SQLumDash3.28.0/src のみに存在: rowlock_pager.c
SQLumDash3.28.0/src のみに存在: rowlock_savepoint.c
SQLumDash3.28.0/src のみに存在: rowlock_savepoint.h
SQLumDash3.28.0/src のみに存在: rowlock_vdbeblob.c
SQLumDash3.28.0/src のみに存在: rowlock_vtab.c
diff -ru sqlite-src-3280000/src/sqlite.h.in SQLumDash3.28.0/src/sqlite.h.in
--- sqlite-src-3280000/src/sqlite.h.in	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/sqlite.h.in	2019-08-21 14:32:45.000000000 +0900
@@ -2027,6 +2027,10 @@
 #define SQLITE_CONFIG_SMALL_MALLOC        27  /* boolean */
 #define SQLITE_CONFIG_SORTERREF_SIZE      28  /* int nByte */
 #define SQLITE_CONFIG_MEMDB_MAXSIZE       29  /* sqlite3_int64 */
+/* The followings are additional config flag for sqlite3_config. */
+#define SQLITE_CONFIG_MMAP_ROW_SIZE       100  /* int nByte */
+#define SQLITE_CONFIG_MMAP_TABLE_SIZE     101  /* int nByte */
+
 
 /*
 ** CAPI3REF: Database Connection Configuration Options
@@ -9388,6 +9392,35 @@
 # undef double
 #endif
 
+/* New error code for SQLumDash. */
+#define SQLITE_CORRUPT_ROWID 99 /* rowid issued automatically is corrupted. */
+
+/* For cleanup tool */
+void sqlite3_rowlock_ipc_unlock_record_all(const char *name);
+void sqlite3_rowlock_ipc_unlock_tables_all(const char *name);
+
+/* For the test */
+typedef struct IpcHandle IpcHandle;
+int sqlite3_rowlock_ipc_init(IpcHandle *pHandle, sqlite3_uint64 nByteRow, sqlite3_uint64 nByteTable, const void *owner, const char *name);
+void sqlite3_rowlock_ipc_finish(IpcHandle *pHandle);
+int sqlite3_rowlock_ipc_lock_record(IpcHandle *pHandle, int iTable, sqlite3_int64 rowid);
+void sqlite3_rowlock_ipc_unlock_record(IpcHandle *pHandle, int iTable, sqlite3_int64 rowid);
+void sqlite3_rowlock_ipc_unlock_record_proc(IpcHandle *pHandle, const char *name);
+int sqlite3_rowlock_ipc_lock_table(IpcHandle *pHandle, int iTable, unsigned char eLock, unsigned char *prevLock);
+unsigned char sqlite3_rowlock_ipc_lock_table_query(IpcHandle *pHandle, int iTable);
+void sqlite3_rowlock_ipc_unlock_table(IpcHandle *pHandle, int iTable);
+void sqlite3_rowlock_ipc_register_hash_func(int iClass, sqlite3_uint64(*xFunc)(void *pMap, ...));
+typedef struct RowLockSavepoint RowLockSavepoint;
+int sqlite3_rowlock_savepoint_init(RowLockSavepoint *pLockSavepoint);
+void sqlite3_rowlock_savepoint(RowLockSavepoint *pLockSavepoint, int op, int iSavepoint, IpcHandle *pHandle, void *pRootPages);
+void sqlite3_rowlock_savepoint_close(RowLockSavepoint *pLockSavepoint);
+int sqlite3_rowlock_savepoint_create(RowLockSavepoint *pLockSavepoint, int iSavepoint);
+int sqlite3_rowlock_history_add_record(RowLockSavepoint *pLockSavepoint, int iTable, sqlite3_int64 rowid);
+int sqlite3_rowlock_history_add_new_table(RowLockSavepoint *pLockSavepoint, int iTable);
+int sqlite3_rowlock_history_add_table_lock(RowLockSavepoint *pLockSavepoint, int iTable, unsigned char prevLock);
+void sqlite3_rowlock_register_unlockRecord_func(void(*xFunc)(IpcHandle*,int,sqlite3_int64));
+void sqlite3_rowlock_register_lockTable_func(int(*xFunc)(IpcHandle*,int,unsigned char));
+void sqlite3_rowlock_register_rootPageDel_func(void*(*xFunc)(void*,sqlite3_int64,void*));
 #ifdef __cplusplus
 }  /* End of the 'extern "C"' block */
 #endif
diff -ru sqlite-src-3280000/src/sqliteInt.h SQLumDash3.28.0/src/sqliteInt.h
--- sqlite-src-3280000/src/sqliteInt.h	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/sqliteInt.h	2019-08-21 14:32:45.000000000 +0900
@@ -1499,6 +1499,12 @@
 #ifdef SQLITE_USER_AUTHENTICATION
   sqlite3_userauth auth;        /* User authentication information */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  u8 inVtabSavepoint;
+  sqlite3_blob **aBlob;
+  int nBlob;
+  u8 keepBlob;
+#endif
 };
 
 /*
@@ -3447,6 +3453,10 @@
   int bInternalFunctions;           /* Internal SQL functions are visible */
   int iOnceResetThreshold;          /* When to reset OP_Once counters */
   u32 szSorterRef;                  /* Min size in bytes to use sorter-refs */
+#ifndef SQLITE_OMIT_ROWLOCK
+  sqlite3_int64 szMmapRowLock;      /* MMAP space for row lock */
+  sqlite3_int64 szMmapTableLock;    /* MMAP space for table lock */
+#endif
 };
 
 /*
SQLumDash3.28.0/src のみに存在: test4_new.c
SQLumDash3.28.0/src のみに存在: test_rowlock.c
diff -ru sqlite-src-3280000/src/test_tclsh.c SQLumDash3.28.0/src/test_tclsh.c
--- sqlite-src-3280000/src/test_tclsh.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/test_tclsh.c	2019-08-21 14:32:45.000000000 +0900
@@ -62,11 +62,13 @@
   extern int Sqlitetest2_Init(Tcl_Interp*);
   extern int Sqlitetest3_Init(Tcl_Interp*);
   extern int Sqlitetest4_Init(Tcl_Interp*);
+  extern int Sqlitetest4_new_Init(Tcl_Interp*);
   extern int Sqlitetest5_Init(Tcl_Interp*);
   extern int Sqlitetest6_Init(Tcl_Interp*);
   extern int Sqlitetest7_Init(Tcl_Interp*);
   extern int Sqlitetest8_Init(Tcl_Interp*);
   extern int Sqlitetest9_Init(Tcl_Interp*);
+  extern int Sqlitetest_rowlock_Init(Tcl_Interp*);
   extern int Sqlitetestasync_Init(Tcl_Interp*);
   extern int Sqlitetest_autoext_Init(Tcl_Interp*);
   extern int Sqlitetest_blob_Init(Tcl_Interp*);
@@ -132,11 +134,13 @@
   Sqlitetest2_Init(interp);
   Sqlitetest3_Init(interp);
   Sqlitetest4_Init(interp);
+  Sqlitetest4_new_Init(interp);
   Sqlitetest5_Init(interp);
   Sqlitetest6_Init(interp);
   Sqlitetest7_Init(interp);
   Sqlitetest8_Init(interp);
   Sqlitetest9_Init(interp);
+  Sqlitetest_rowlock_Init(interp);
   Sqlitetestasync_Init(interp);
   Sqlitetest_autoext_Init(interp);
   Sqlitetest_blob_Init(interp);
diff -ru sqlite-src-3280000/src/trigger.c SQLumDash3.28.0/src/trigger.c
--- sqlite-src-3280000/src/trigger.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/trigger.c	2019-08-21 13:46:14.000000000 +0900
@@ -628,6 +628,8 @@
   }
 #endif
 
+  ROWLOCK_TABLE_LOCK_FOR_TRIGGER();
+
   /* Generate code to destroy the database record of the trigger.
   */
   assert( pTable!=0 );
diff -ru sqlite-src-3280000/src/vacuum.c SQLumDash3.28.0/src/vacuum.c
--- sqlite-src-3280000/src/vacuum.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vacuum.c	2019-08-21 14:32:45.000000000 +0900
@@ -17,6 +17,8 @@
 #include "sqliteInt.h"
 #include "vdbeInt.h"
 
+#include "rowlock.h"
+
 #if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)
 
 /*
@@ -253,9 +255,16 @@
   ** file. This is done before the sqlite3BtreeGetPageSize(pMain) call below,
   ** to ensure that we do not try to change the page-size on a WAL database.
   */
+#ifndef SQLITE_OMIT_ROWLOCK
+  ROWLOCK_VACUM_LOCK(pMain);
+#endif
   rc = execSql(db, pzErrMsg, "BEGIN");
   if( rc!=SQLITE_OK ) goto end_of_vacuum;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeBeginTransOriginal(pMain, pOut==0 ? 2 : 0, 0);
+#else
   rc = sqlite3BtreeBeginTrans(pMain, pOut==0 ? 2 : 0, 0);
+#endif
   if( rc!=SQLITE_OK ) goto end_of_vacuum;
 
   /* Do not attempt to change the page size for a WAL database */
diff -ru sqlite-src-3280000/src/vdbe.c SQLumDash3.28.0/src/vdbe.c
--- sqlite-src-3280000/src/vdbe.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vdbe.c	2019-08-21 14:32:46.000000000 +0900
@@ -20,6 +20,9 @@
 */
 #include "sqliteInt.h"
 #include "vdbeInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /*
 ** Invoke this macro on memory cells just prior to changing the
@@ -1006,7 +1009,7 @@
 case OP_Halt: {
   VdbeFrame *pFrame;
   int pcx;
-
+  ROWLOCK_SET_FORCE_COMMIT(p);
   pcx = (int)(pOp - aOp);
 #ifdef SQLITE_DEBUG
   if( pOp->p2==OE_Abort ){ sqlite3VdbeAssertAbortable(p); }
@@ -1416,7 +1419,15 @@
   ** The statement transaction is never a top-level transaction.  Hence
   ** the RELEASE call below can never fail.
   */
+#ifndef SQLITE_OMIT_ROWLOCK
+  /* Rowlock feature enables statement journal for write transaction
+  ** including sqlite3_open_blob(). In this case, iStatement becomes
+  ** non-zero value.
+  */
+  assert( p->iStatement==0 || db->flags&SQLITE_CountRows || p->usesStmtJournal );
+#else
   assert( p->iStatement==0 || db->flags&SQLITE_CountRows );
+#endif
   rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE);
   assert( rc==SQLITE_OK );
 
@@ -3035,6 +3046,7 @@
                                 db->nStatement+db->nSavepoint);
       if( rc!=SQLITE_OK ) goto abort_due_to_error;
 #endif
+      ROWLOCK_SAVEPOINT_CREATE();
 
       /* Create a new savepoint structure. */
       pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint)+nName+1);
@@ -3287,7 +3299,7 @@
       }
       goto abort_due_to_error;
     }
-
+    ROWLOCK_ENABLE_STMT_JOURNAL();
     if( pOp->p2 && p->usesStmtJournal 
      && (db->autoCommit==0 || db->nVdbeRead>1) 
     ){
@@ -3604,6 +3616,7 @@
   sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
                                (pOp->p5 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));
   if( rc ) goto abort_due_to_error;
+  ROWLOCK_CACHED_ROWID_SET_BY_OPEN_CURSOR();
   break;
 }
 
@@ -4001,7 +4014,11 @@
         if( (oc & 0x0001)==(OP_SeekLT & 0x0001) ) oc++;
       }
     } 
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, 0, (u64)iKey, 0, &res, pOp->opcode);
+#else
     rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);
+#endif
     pC->movetoTarget = iKey;  /* Used by OP_Delete */
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
@@ -4045,7 +4062,11 @@
     { int i; for(i=0; i<r.nField; i++) assert( memIsValid(&r.aMem[i]) ); }
 #endif
     r.eqSeen = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, &r, 0, 0, &res, pOp->opcode);
+#else
     rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, &r, 0, 0, &res);
+#endif
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
     }
@@ -4062,7 +4083,11 @@
   if( oc>=OP_SeekGE ){  assert( oc==OP_SeekGE || oc==OP_SeekGT );
     if( res<0 || (res==0 && oc==OP_SeekGT) ){
       res = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+      rc = sqlite3BtreeNextAll(pC->uc.pCursor, 0);
+#else
       rc = sqlite3BtreeNext(pC->uc.pCursor, 0);
+#endif
       if( rc!=SQLITE_OK ){
         if( rc==SQLITE_DONE ){
           rc = SQLITE_OK;
@@ -4078,7 +4103,11 @@
     assert( oc==OP_SeekLT || oc==OP_SeekLE );
     if( res>0 || (res==0 && oc==OP_SeekLT) ){
       res = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+      rc = sqlite3BtreePreviousAll(pC->uc.pCursor, 0);
+#else
       rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);
+#endif
       if( rc!=SQLITE_OK ){
         if( rc==SQLITE_DONE ){
           rc = SQLITE_OK;
@@ -4281,7 +4310,11 @@
       }
     }
   }
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, pIdxKey, 0, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);
+#endif
   if( pFree ) sqlite3DbFreeNN(db, pFree);
   if( rc!=SQLITE_OK ){
     goto abort_due_to_error;
@@ -4383,7 +4416,11 @@
   assert( pCrsr!=0 );
   res = 0;
   iKey = pIn3->u.i;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pCrsr, 0, iKey, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
+#endif
   assert( rc==SQLITE_OK || res==0 );
   pC->movetoTarget = iKey;  /* Used by OP_Delete */
   pC->nullRow = 0;
@@ -4479,7 +4516,11 @@
 #   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
 #endif
 
+    ROWLOCK_CACHED_ROWID_FLAG_SET();
     if( !pC->useRandomRowid ){
+#ifndef SQLITE_OMIT_ROWLOCK
+      ROWLOCK_CACHED_ROWID_NEW_ROWID();
+#else
       rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
       if( rc!=SQLITE_OK ){
         goto abort_due_to_error;
@@ -4495,6 +4536,7 @@
           v++;   /* IMP: R-29538-34987 */
         }
       }
+#endif
     }
 
 #ifndef SQLITE_OMIT_AUTOINCREMENT
@@ -4538,8 +4580,13 @@
       do{
         sqlite3_randomness(sizeof(v), &v);
         v &= (MAX_ROWID>>1); v++;  /* Ensure that v is greater than zero */
+#ifndef SQLITE_OMIT_ROWLOCK
+      }while(  ((rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, 0, (u64)v,
+                                                 0, &res, pOp->opcode))==SQLITE_OK)
+#else
       }while(  ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,
                                                  0, &res))==SQLITE_OK)
+#endif
             && (res==0)
             && (++cnt<100));
       if( rc ) goto abort_due_to_error;
@@ -4553,6 +4600,7 @@
     pC->cacheStatus = CACHE_STALE;
   }
   pOut->u.i = v;
+  ROWLOCK_CACHED_ROWID_SET();
   break;
 }
 
@@ -4619,6 +4667,7 @@
   assert( memIsValid(pKey) );
   REGISTER_TRACE(pOp->p3, pKey);
   x.nKey = pKey->u.i;
+  ROWLOCK_CACHED_ROWID_UPDATE();
 
   if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
     assert( pC->iDb>=0 );
@@ -4656,9 +4705,15 @@
     x.nZero = 0;
   }
   x.pKey = 0;
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeInsert(pC->uc.pCursor, &x,
+      (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult
+  );
+#else
   rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult
   );
+#endif
   pC->deferredMoveto = 0;
   pC->cacheStatus = CACHE_STALE;
 
@@ -4787,7 +4842,11 @@
   }
 #endif
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeDelete(pC->uc.pCursor, pOp->p5);
+#else
   rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);
+#endif
   pC->cacheStatus = CACHE_STALE;
   pC->seekResult = 0;
   if( rc ) goto abort_due_to_error;
@@ -5170,7 +5229,11 @@
     assert( pC->eCurType==CURTYPE_BTREE );
     pCrsr = pC->uc.pCursor;
     assert( pCrsr );
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeFirstAll(pCrsr, &res);
+#else
     rc = sqlite3BtreeFirst(pCrsr, &res);
+#endif
     pC->deferredMoveto = 0;
     pC->cacheStatus = CACHE_STALE;
   }
@@ -5271,7 +5334,11 @@
        || pC->seekOp==OP_Last 
        || pC->seekOp==OP_NullRow);
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeAdvanceAll(pC->uc.pCursor, pOp->p3, pOp->p4.xAdvance);
+#else
   rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
+#endif
 next_tail:
   pC->cacheStatus = CACHE_STALE;
   VdbeBranchTaken(rc==SQLITE_OK,2);
@@ -5348,10 +5415,17 @@
     x.pKey = pIn2->z;
     x.aMem = aMem + pOp->p3;
     x.nMem = (u16)pOp->p4.i;
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3TransBtreeInsert(pC->uc.pCursor, &x,
+         (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), 
+        ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
+        );
+#else
     rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
          (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), 
         ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
         );
+#endif
     assert( pC->deferredMoveto==0 );
     pC->cacheStatus = CACHE_STALE;
   }
@@ -5386,10 +5460,18 @@
   r.nField = (u16)pOp->p3;
   r.default_rc = 0;
   r.aMem = &aMem[pOp->p2];
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(pCrsr, &r, 0, 0, &res, pOp->opcode);
+#else
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
+#endif
   if( rc ) goto abort_due_to_error;
   if( res==0 ){
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3TransBtreeDelete(pCrsr, BTREE_AUXDELETE);
+#else
     rc = sqlite3BtreeDelete(pCrsr, BTREE_AUXDELETE);
+#endif
     if( rc ) goto abort_due_to_error;
   }
   assert( pC->deferredMoveto==0 );
@@ -5620,7 +5702,11 @@
     iDb = pOp->p3;
     assert( DbMaskTest(p->btreeMask, iDb) );
     iMoved = 0;  /* Not needed.  Only to silence a warning. */
+#ifndef SQLITE_OMIT_ROWLOCK
+    rc = sqlite3BtreeDropTableAll(db->aDb[iDb].pBt, pOp->p1, &iMoved);
+#else
     rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
+#endif
     pOut->flags = MEM_Int;
     pOut->u.i = iMoved;
     if( rc ) goto abort_due_to_error;
@@ -5661,9 +5747,15 @@
   nChange = 0;
   assert( p->readOnly==0 );
   assert( DbMaskTest(p->btreeMask, pOp->p2) );
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3TransBtreeClearTable(
+      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
+  );
+#else
   rc = sqlite3BtreeClearTable(
       db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
   );
+#endif
   if( pOp->p3 ){
     p->nChange += nChange;
     if( pOp->p3>0 ){
@@ -6808,7 +6900,11 @@
     int p1 = pOp->p1; 
     assert( p1>=0 && p1<db->nDb );
     assert( DbMaskTest(p->btreeMask, p1) );
+#ifndef SQLITE_OMIT_ROWLOCK
+    assert( isWriteLock==0 || isWriteLock==1 || isWriteLock==2 );
+#else
     assert( isWriteLock==0 || isWriteLock==1 );
+#endif
     rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
     if( rc ){
       if( (rc&0xFF)==SQLITE_LOCKED ){
@@ -6817,6 +6913,8 @@
       }
       goto abort_due_to_error;
     }
+    rc = rowlockBtreeCacheReset(db->aDb[p1].pBt);
+    if( rc ) goto abort_due_to_error;
   }
   break;
 }
diff -ru sqlite-src-3280000/src/vdbeInt.h SQLumDash3.28.0/src/vdbeInt.h
--- sqlite-src-3280000/src/vdbeInt.h	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vdbeInt.h	2019-08-21 14:32:46.000000000 +0900
@@ -445,6 +445,10 @@
   int nScan;              /* Entries in aScan[] */
   ScanStatus *aScan;      /* Scan definitions for sqlite3_stmt_scanstatus() */
 #endif
+#ifndef SQLITE_OMIT_ROWLOCK
+  u8 forceCommit;         /* True for statements that do commit forcibly by DDL */
+  u8 stmtJournalEnabled;  /* True if usesStmtJournal is enabled by the execution */
+#endif
 };
 
 /*
diff -ru sqlite-src-3280000/src/vdbeapi.c SQLumDash3.28.0/src/vdbeapi.c
--- sqlite-src-3280000/src/vdbeapi.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vdbeapi.c	2019-08-21 14:32:46.000000000 +0900
@@ -16,6 +16,8 @@
 #include "sqliteInt.h"
 #include "vdbeInt.h"
 
+ROWLOCK_CACHED_ROWID_RETRY
+
 #ifndef SQLITE_OMIT_DEPRECATED
 /*
 ** Return TRUE (non-zero) of the statement supplied as an argument needs
@@ -550,7 +552,7 @@
 ** schema change has occurred.  That detail is handled by the
 ** outer sqlite3_step() wrapper procedure.
 */
-static int sqlite3Step(Vdbe *p){
+static int sqlite3StepOriginal(Vdbe *p){
   sqlite3 *db;
   int rc;
 
diff -ru sqlite-src-3280000/src/vdbeaux.c SQLumDash3.28.0/src/vdbeaux.c
--- sqlite-src-3280000/src/vdbeaux.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vdbeaux.c	2019-08-21 14:32:46.000000000 +0900
@@ -14,6 +14,9 @@
 */
 #include "sqliteInt.h"
 #include "vdbeInt.h"
+#ifndef SQLITE_OMIT_ROWLOCK
+#include "rowlock.h"
+#endif
 
 /*
 ** Create a new virtual database engine.
@@ -2468,7 +2471,7 @@
   */ 
   for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ 
     Btree *pBt = db->aDb[i].pBt;
-    if( sqlite3BtreeIsInTrans(pBt) ){
+    if( sqlite3BtreeIsInTransOriginal(pBt) ){
       /* Whether or not a database might need a master journal depends upon
       ** its journal mode (among other things).  This matrix determines which
       ** journal modes use a master journal and which do not */
@@ -2827,6 +2830,9 @@
 int sqlite3VdbeHalt(Vdbe *p){
   int rc;                         /* Used to store transient return codes */
   sqlite3 *db = p->db;
+#ifndef SQLITE_OMIT_ROWLOCK
+  BlobHandle *pBlobHandle = NULL;
+#endif
 
   /* This function contains the logic that determines if a statement or
   ** transaction will be committed or rolled back as a result of the
@@ -2900,6 +2906,8 @@
       sqlite3VdbeCheckFk(p, 0);
     }
   
+    ROWLOCK_BLOB_CLOSE(db, p);
+
     /* If the auto-commit flag is set and this is the only active writer 
     ** VM, then we do either a commit or rollback of the current transaction. 
     **
@@ -2919,6 +2927,14 @@
           }
           rc = SQLITE_CONSTRAINT_FOREIGNKEY;
         }else{ 
+#ifndef SQLITE_OMIT_ROWLOCK
+          rc = sqlite3BtreeBeginTransForCommit(db);
+          if( rc ){
+            sqlite3VdbeLeave(p);
+            return rc;
+          }
+#endif
+
           /* The auto-commit flag is true, the vdbe program was successful 
           ** or hit an 'OR FAIL' constraint and there are no deferred foreign
           ** key constraints to hold up the transaction. This means a commit 
@@ -2993,6 +3009,10 @@
     sqlite3VdbeLeave(p);
   }
 
+#ifndef SQLITE_OMIT_ROWLOCK
+  ROWLOCK_VDBE_HALT(p);
+#endif
+
   /* We have successfully halted and closed the VM.  Record this fact. */
   if( p->pc>=0 ){
     db->nVdbeActive--;
@@ -3306,7 +3326,11 @@
   assert( p->deferredMoveto );
   assert( p->isTable );
   assert( p->eCurType==CURTYPE_BTREE );
+#ifndef SQLITE_OMIT_ROWLOCK
+  rc = sqlite3BtreeMovetoUnpackedAll(p->uc.pCursor, 0, p->movetoTarget, 0, &res, 0);
+#else
   rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);
+#endif
   if( rc ) return rc;
   if( res!=0 ) return SQLITE_CORRUPT_BKPT;
 #ifdef SQLITE_TEST
diff -ru sqlite-src-3280000/src/vdbeblob.c SQLumDash3.28.0/src/vdbeblob.c
--- sqlite-src-3280000/src/vdbeblob.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vdbeblob.c	2019-08-21 13:34:53.000000000 +0900
@@ -116,7 +116,7 @@
 /*
 ** Open a blob handle.
 */
-int sqlite3_blob_open(
+int sqlite3_blob_open_original(
   sqlite3* db,            /* The database connection */
   const char *zDb,        /* The attached database containing the blob */
   const char *zTable,     /* The table containing the blob */
@@ -349,7 +349,7 @@
 ** Close a blob handle that was previously created using
 ** sqlite3_blob_open().
 */
-int sqlite3_blob_close(sqlite3_blob *pBlob){
+int sqlite3_blob_close_original(sqlite3_blob *pBlob){
   Incrblob *p = (Incrblob *)pBlob;
   int rc;
   sqlite3 *db;
@@ -504,4 +504,9 @@
   return rc;
 }
 
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_VDBEBLOB_C
+#include "rowlock_vdbeblob.c"
+#undef SQLUMDASH_INCLUDED_FROM_VDBEBLOB_C
+#endif
 #endif /* #ifndef SQLITE_OMIT_INCRBLOB */
diff -ru sqlite-src-3280000/src/vtab.c SQLumDash3.28.0/src/vtab.c
--- sqlite-src-3280000/src/vtab.c	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/src/vtab.c	2019-08-21 14:32:46.000000000 +0900
@@ -994,7 +994,7 @@
 ** function immediately. If all calls to virtual table methods are successful,
 ** SQLITE_OK is returned.
 */
-int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){
+int sqlite3VtabSavepointOriginal(sqlite3 *db, int op, int iSavepoint){
   int rc = SQLITE_OK;
 
   assert( op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN );
@@ -1249,4 +1249,9 @@
   return rc;
 }
 
+#ifndef SQLITE_AMALGAMATION
+#define SQLUMDASH_INCLUDED_FROM_VTAB_C
+#include "rowlock_vtab.c"
+#undef SQLUMDASH_INCLUDED_FROM_VTAB_C
+#endif
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
diff -ru sqlite-src-3280000/test/permutations.test SQLumDash3.28.0/test/permutations.test
--- sqlite-src-3280000/test/permutations.test	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/test/permutations.test	2019-08-21 14:32:46.000000000 +0900
@@ -920,6 +920,25 @@
   test_set $::allquicktests shared_err.test -exclude async3.test
 ]
 
+#List of test that need huge MMap
+# select2.test
+# speed4.test
+test_suite "SQLumdash-huge-mmap-testsuite" -description {
+  Run test that need large MMap for much step in a transaction
+} -initialize {
+  catch {db close}
+  sqlite3_shutdown
+  catch {sqlite3_rowlock_config_mmap CONFIG_ROWLOCK_MMAP_SIZE 52428800}
+  sqlite3_initialize
+} -files {
+  select2.test
+} -shutdown {
+  catch {db close}
+  sqlite3_shutdown
+  catch {sqlite3_rowlock_config_mmap CONFIG_ROWLOCK_MMAP_SIZE 1048576}
+  sqlite3_initialize
+}
+
 # The set of tests to run on the alternative-pcache
 set perm-alt-pcache-testset {
   async.test
SQLumDash3.28.0/test のみに存在: rowlock_common.tcl
SQLumDash3.28.0/test のみに存在: sqlumdash_huge_mmap_testsuite.test
diff -ru sqlite-src-3280000/test/tester.tcl SQLumDash3.28.0/test/tester.tcl
--- sqlite-src-3280000/test/tester.tcl	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/test/tester.tcl	2019-08-21 14:32:46.000000000 +0900
@@ -527,6 +527,13 @@
         set cmdlinearg(verbose) 2
       }
 
+
+      # add switch mode
+      {^-+mode=.+$} {
+        foreach {dummy cmdlinearg(switchmode)} [split $a =] break
+        set ::G(switchmode) $cmdlinearg(switchmode)
+      }
+
       default {
         if {[file tail $a]==$a} {
           lappend leftover $a
SQLumDash3.28.0/tool のみに存在: addopcodes.tcl
diff -ru sqlite-src-3280000/tool/mksqlite3c-noext.tcl SQLumDash3.28.0/tool/mksqlite3c-noext.tcl
--- sqlite-src-3280000/tool/mksqlite3c-noext.tcl	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/tool/mksqlite3c-noext.tcl	2019-08-21 13:34:53.000000000 +0900
@@ -119,6 +119,16 @@
    vxworks.h
    wal.h
    whereInt.h
+   rowlock.h
+   rowlock_hash.h
+   rowlock_ipc.h
+   rowlock_ipc_row.h
+   rowlock_ipc_table.h
+   rowlock_macro.h
+   rowlock_os.h
+   rowlock_os_linux.h
+   rowlock_os_win.h
+   rowlock_savepoint.h
 } {
   set available_hdr($hdr) 1
 }
@@ -336,6 +346,7 @@
    callback.c
    delete.c
    func.c
+   funcNew.c
    fkey.c
    insert.c
    legacy.c
@@ -353,6 +364,20 @@
    where.c
    window.c
 
+   rowlock.c
+   rowlock_btree.c
+   rowlock_hash.c
+   rowlock_ipc.c
+   rowlock_ipc_row.c
+   rowlock_ipc_table.c
+   rowlock_main.c
+   rowlock_os_linux.c
+   rowlock_os_win.c
+   rowlock_pager.c
+   rowlock_savepoint.c
+   rowlock_vdbeblob.c
+   rowlock_vtab.c
+
    parse.c
 
    tokenize.c
diff -ru sqlite-src-3280000/tool/mksqlite3c.tcl SQLumDash3.28.0/tool/mksqlite3c.tcl
--- sqlite-src-3280000/tool/mksqlite3c.tcl	2019-04-17 05:06:03.000000000 +0900
+++ SQLumDash3.28.0/tool/mksqlite3c.tcl	2019-08-21 14:50:23.000000000 +0900
@@ -127,6 +127,16 @@
    vxworks.h
    wal.h
    whereInt.h
+   rowlock.h
+   rowlock_hash.h
+   rowlock_ipc.h
+   rowlock_ipc_row.h
+   rowlock_ipc_table.h
+   rowlock_macro.h
+   rowlock_os.h
+   rowlock_os_linux.h
+   rowlock_os_win.h
+   rowlock_savepoint.h
 } {
   set available_hdr($hdr) 1
 }
@@ -212,7 +222,11 @@
       } else {
         # Comment out the entire line, replacing any nested comment
         # begin/end markers with the harmless substring "**".
-        puts $out "/* [string map [list /* ** */ **] $line] */"
+        if {$hdr=="pthread.h"} {
+          puts $out $line
+        } else {
+          puts $out "/* [string map [list /* ** */ **] $line] */"
+        }
       }
     } elseif {[regexp {^#ifdef __cplusplus} $line]} {
       puts $out "#if 0"
@@ -354,6 +368,7 @@
    callback.c
    delete.c
    func.c
+   funcNew.c
    fkey.c
    insert.c
    legacy.c
@@ -372,6 +387,20 @@
    where.c
    window.c
 
+   rowlock.c
+   rowlock_btree.c
+   rowlock_hash.c
+   rowlock_ipc.c
+   rowlock_ipc_row.c
+   rowlock_ipc_table.c
+   rowlock_main.c
+   rowlock_os_linux.c
+   rowlock_os_win.c
+   rowlock_pager.c
+   rowlock_savepoint.c
+   rowlock_vdbeblob.c
+   rowlock_vtab.c
+
    parse.c
 
    tokenize.c
SQLumDash3.28.0/tool のみに存在: rowlock_cleaner.c
SQLumDash3.28.0/tool/win のみに存在: uniq.bat
